<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Zodiac PowerCard (ÏµúÏ¢Ö Î∞∏Îü∞Ïä§ ÏàòÏ†ï)</title>
    <style>
        :root {
            --bg-color: #1a1c20;
            --surface-color: #2c2f36;
            --primary-text: #f0f2f5;
            --secondary-text: #a9b1c2;
            --gold-color: #ffd700;
            --red-glow: #ff4747;
            --purple-glow: #da70d6;
            --orange-glow: #ffae42;
            --blue-glow: #00bfff;
            --green-glow: #00ff87;
            --card-bg: #3e424a;
        }
        * { box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: var(--bg-color);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: var(--primary-text);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        .game-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #start-screen, .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(26, 28, 32, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; text-align: center;
            transition: opacity 0.5s ease-out, visibility 0.5s;
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            visibility: hidden; opacity: 0;
        }
        .modal.show { visibility: visible; opacity: 1; animation: fadeIn 0.3s; }
        #start-screen h1 { font-size: clamp(2em, 10vw, 3em); color: var(--gold-color); text-shadow: 0 0 15px var(--gold-color); }
        .animal-showcase {
            font-size: clamp(2em, 10vw, 3em);
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            justify-items: center;
            max-width: 90vw;
        }
        .animal-showcase img { width: 1.1em; height: 1.1em; }
        #start-button {
            padding: 15px 40px; font-size: 1.5em; font-weight: bold; border: none;
            background: linear-gradient(45deg, #6a11cb, #2575fc);
            color: white; border-radius: 12px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-button:hover { transform: scale(1.05); box-shadow: 0 0 20px #6a11cb; }
        .copyright { position: absolute; bottom: 10px; font-size: 0.7em; color: var(--secondary-text); }
        .game-container {
            display: none;
            width: 100%;
            max-width: 600px;
            height: 100%;
            max-height: 95vh;
            background: var(--surface-color);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            padding: clamp(10px, 2vw, 15px);
            flex-direction: column;
            gap: clamp(5px, 1.5vh, 10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.2);
            padding: clamp(8px, 2vw, 12px);
            border-radius: 12px;
            gap: clamp(8px, 2vw, 12px);
        }
        .info-box {
            text-align: center;
        }
        .info-box h2 {
            margin: 0 0 2px 0;
            font-size: 0.8em;
            font-weight: 600;
            color: var(--secondary-text);
        }
        .info-box p {
            margin: 0;
            font-size: clamp(1.2em, 3.5vw, 1.5em);
            font-weight: 700;
        }
        .info-box-large {
            flex-grow: 1;
            position: relative;
            padding-top: 10px;
        }
        .progress-bar-bg {
            width: 100%;
            height: 24px;
            background-color: #1a1c20;
            border-radius: 12px;
            position: relative;
            overflow: visible; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 12px;
            transition: width 0.4s ease-out, background-color 0.4s ease-in-out;
            display: flex;
            align-items: center;
            position: relative;
        }
        
        .progress-target-marker {
            position: absolute;
            bottom: -15px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid var(--gold-color);
            transform: translateX(-50%);
            z-index: 2;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
            transition: transform 0.3s ease;
        }
        .progress-target-marker.target-reached-effect {
            animation: target-pulse 0.6s ease-in-out;
        }
        @keyframes target-pulse {
            50% { transform: translateX(-50%) scale(1.4); }
        }
        
        .target-text-container {
            position: absolute;
            top: -32px;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 900;
            color: var(--primary-text);
            background-color: var(--surface-color);
            padding: 3px 10px;
            border-radius: 8px;
            z-index: 3;
            white-space: nowrap;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            border: 1px solid var(--gold-color);
        }
        
        .target-label {
            position: absolute;
            bottom: -14px;
            font-size: 0.8em;
            font-weight: bold;
            color: var(--secondary-text);
            transform: translateX(-160%);
            white-space: nowrap;
        }

        .progress-text-container {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            padding: 0 8px;
        }
        .progress-text {
            font-size: clamp(0.8em, 2.8vw, 1.0em);
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            white-space: nowrap;
        }
        .progress-text.score-updated {
            animation: score-pop 0.3s ease-out;
        }
        @keyframes score-pop {
            50% { transform: scale(1.2); }
        }
        .header-stats-overlay {
            display: flex;
            justify-content: space-between;
            padding: 4px 10px 0 10px;
        }
        .header-stat {
            font-size: clamp(0.9em, 2.8vw, 1.1em);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            transition: transform 0.2s ease, color 0.2s ease;
        }
        .header-stat.ui-update-effect {
            animation: ui-shake 0.4s ease-in-out;
            color: var(--gold-color);
        }
        @keyframes ui-shake {
            25% { transform: scale(1.2) rotate(-5deg); }
            75% { transform: scale(1.2) rotate(5deg); }
        }

        .color-red { background: linear-gradient(90deg, #c83a3a, var(--red-glow)); }
        .color-yellow { background: linear-gradient(90deg, #d4a017, var(--orange-glow)); }
        .color-green { background: linear-gradient(90deg, #008f5a, var(--green-glow)); }
        .color-blue { background: linear-gradient(90deg, #007bff, var(--blue-glow)); }
        .color-gold { background: linear-gradient(90deg, #b8860b, var(--gold-color)); }

        .game-board-wrapper {
            position: relative;
            flex-grow: 1;
            min-height: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1vh 0;
        }
        
        .board-container {
            position: relative;
            width: 100%;
            height: auto;
            max-width: 340px;
            max-height: 100%;
            aspect-ratio: 5 / 7;
        }

        #game-board, #effects-layer, #html-effects-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #html-effects-layer {
            pointer-events: none;
            z-index: 20;
            overflow: visible;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2%;
            padding: 2%;
            z-index: 1;
        }
        
        .card { 
            aspect-ratio: 5 / 7;
            background: linear-gradient(145deg, #4a4e56, #34373d);
            border-radius: 8px; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            cursor: grab; 
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative; 
            user-select: none; 
            border: 1px solid #2a2d32;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3), inset 0 0 2px rgba(255,255,255,0.05);
            overflow: hidden;
            padding: 4px;
        }
        
        .card.cursed {
            background: linear-gradient(145deg, #5c1e1e, #a83232);
            border: 1px solid var(--red-glow);
            box-shadow: 0 0 15px var(--red-glow);
            font-size: 1.5em;
            color: #1a1c20;
            text-shadow: 0 0 3px var(--red-glow);
        }
        .card.cursed::after {
            content: 'BOSS';
            position: absolute;
            bottom: 4px;
            font-size: 0.4em;
            font-weight: bold;
            color: var(--primary-text);
            text-shadow: 1px 1px 2px black;
        }

        /* [MODIFIED] Î≥¥Ïä§ Ïπ¥Îìú ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò */
        @keyframes shatter-animation {
            0% { transform: translate(0, 0) rotate(0deg) scale(1); opacity: 1; }
            10% { transform: translate(-3px, -3px) rotate(-3deg); }
            20% { transform: translate(3px, 3px) rotate(3deg); }
            30% { transform: translate(-3px, 2px) rotate(0deg); }
            40% { transform: translate(3px, -2px) rotate(4deg); }
            50% { transform: translate(-3px, 3px) rotate(-2deg); }
            60% { transform: translate(3px, 2px) rotate(0deg); }
            70% { transform: translate(-4px, 3px) rotate(-4deg); }
            80% { transform: translate(3px, -3px) rotate(3deg); }
            90% { transform: translate(-2px, 3px) rotate(0deg); }
            100% { transform: translate(0, 0) rotate(0deg) scale(0.4); opacity: 0; }
        }
        .card.cursed-destroy {
            animation: shatter-animation 0.5s ease-in-out forwards;
            transform-origin: center;
        }

        .card-animal { 
            font-size: clamp(1.4em, 5vw, 1.8em);
            line-height: 1; 
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60%;
            height: auto;
            aspect-ratio: 1/1;
            margin: auto;
        }
        .card-animal img { width: 100%; height: 100%; }
        
        .card-number {
            position: absolute;
            font-size: clamp(0.6em, 2.5vw, 0.9em);
            font-weight: 900;
            color: var(--primary-text);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            bottom: 5px;
            right: 8px;
        }
        .card-number.small {
             font-size: clamp(0.5em, 2vw, 0.8em);
        }
        
        .card.shake-effect { animation: shake-effect 0.5s ease-in-out; }
        @keyframes shake-effect {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-4px); }
            40%, 80% { transform: translateX(4px); }
        }
        .rank-aura-effect {
            position: absolute;
            top: 50%; left: 50%;
            width: 150%; 
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0.7;
            animation: rank-aura-pulse 0.8s ease-out forwards;
        }
        @keyframes rank-aura-pulse {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0.7; }
            to { transform: translate(-50%, -50%) scale(3.5); opacity: 0; }
        }

        .card.placeholder { opacity: 0.2; background-color: rgba(0,0,0,0.3); border: 2px dashed var(--secondary-text); }
        .card.placeholder > * { visibility: hidden; }
        .card.merging { animation: merge-effect 0.4s ease-in-out; z-index: 5; }
        .card.spawn-effect { animation: spawn-effect 0.4s ease-out; }
        @keyframes merge-effect { 50% { transform: scale(1.2); box-shadow: 0 0 25px var(--gold-color); } 100% { transform: scale(1); } }
        @keyframes spawn-effect { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .card.merge-preview {
            transform: scale(1.05);
            box-shadow: 0 0 20px 5px var(--gold-color);
        }
        .card.swap-preview {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px var(--blue-glow);
        }

        .card.border-green { box-shadow: 0 0 10px var(--green-glow); border-color: var(--green-glow); }
        .card.border-blue { box-shadow: 0 0 10px var(--blue-glow); border-color: var(--blue-glow); }
        .card.border-orange { box-shadow: 0 0 10px var(--orange-glow); border-color: var(--orange-glow); }
        .card.border-purple { box-shadow: 0 0 12px var(--purple-glow); border-color: var(--purple-glow); }
        .card.border-red { box-shadow: 0 0 14px var(--red-glow); border-color: var(--red-glow); }
        .card.border-gold { box-shadow: 0 0 16px var(--gold-color); border-color: var(--gold-color); }

        .floating-text { 
            position: absolute; 
            font-weight: bold; 
            text-shadow: 0 0 8px black; 
            animation: float-up 1.5s ease-out forwards; 
            white-space: nowrap; 
            z-index: 20; 
            font-size: 1.2em;
            transform: translate(-50%, -50%);
            color: var(--effect-color, var(--primary-text));
        }
        @keyframes float-up { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -250%) scale(1.3); opacity: 0; } }
        
        #stage-end-screen, #relic-selection-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(26, 28, 32, 0.95);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: none;
            flex-direction: column;
            padding: 20px;
            animation: fadeIn 0.5s;
        }
        #stage-end-content, #relic-selection-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .stage-clear-text, .relic-title-text { 
            font-size: clamp(2em, 10vw, 3em); 
            color: var(--gold-color); 
            text-shadow: 0 0 15px var(--gold-color); 
            animation: pulse-clear 1.5s infinite;
            margin-bottom: 10px;
        }
        @keyframes pulse-clear { 50% { transform: scale(1.05); } }
        
        .shop-container, .relic-container {
            width: 100%;
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        .shop-items, .relic-items { 
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        .item, .relic-item { 
            background: rgba(0,0,0,0.3); 
            padding: 12px; 
            border-radius: 8px; 
            text-align: left; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            font-size: 0.9em; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .relic-item {
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
        }
        .relic-item:hover {
            background-color: rgba(255,255,255,0.1);
            transform: scale(1.02);
        }
        .item-info h4, .relic-info h4 { margin: 0 0 4px 0; font-size: 1.1em; color: var(--primary-text); }
        .item-info p, .relic-info p { margin: 0; font-size: 0.85em; color: var(--secondary-text); }
        .relic-icon { font-size: 2em; margin-right: 15px; }
        .item-cost {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--gold-color);
            margin-right: 10px;
        }
        .action-button { 
            padding: 10px 20px; 
            font-size: 1.1em; 
            font-weight: bold; 
            border: none; 
            background-color: #2575fc; 
            color: white; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.2s; 
            width: 100%;
            margin-top: auto;
        }
        .action-button:hover { background-color: #1a63d1; }
        .action-button:disabled { background-color: #555; cursor: not-allowed; }

        .status-bar { background: rgba(0,0,0,0.2); padding: 6px; border-radius: 8px; text-align: center; flex-shrink: 0; font-size: 0.8em; }
        .status-bar h4 { margin: 0 0 3px 0; font-size: 0.9em; color: var(--secondary-text); }
        .icon-container { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; }
        .icon-container span { font-size: 1.3em; cursor: pointer; position: relative; display: inline-flex; align-items: center; justify-content: center; width: 1.5em; height: 1.5em;}
        .icon-container span img { width: 100%; height: 100%; }
        .icon-container span.banned { opacity: 0.5; filter: grayscale(1); }
        
        /* [MODIFIED] Ïä§ÌÖåÏù¥ÏßÄ ÎèôÎ¨º ÏïÑÏù¥ÏΩò UI Í∞úÏÑ† */
        #animal-status-bar .icon-container {
            flex-wrap: nowrap;
            gap: clamp(4px, 1vw, 6px);
            overflow-x: auto;
        }
        #animal-status-bar .icon-container span {
            font-size: clamp(1em, 3.5vw, 1.2em);
            flex-shrink: 0;
        }

        .modal-content { background: var(--surface-color); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(255, 255, 255, 0.1); animation: slide-down 0.4s ease-out; min-width: 80%; max-width: 95%; }
        #tooltip-icon { font-size: 2.5em; margin-bottom: 8px; }
        #tooltip-desc { font-size: 1em; color: var(--secondary-text); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slide-down { from { transform: translateY(-30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        #effects-layer {
            pointer-events: none;
            z-index: 10;
            overflow: visible;
        }
        
        .combo-path {
            stroke-width: 6; 
            stroke-linecap: round;
            fill: none;
            stroke: url(#combo-gradient);
            filter: url(#glow);
        }
        
        @keyframes combo-flow {
            to {
                stroke-dashoffset: 0;
            }
        }
        .combo-path.animate {
            animation: combo-flow 0.5s ease-out forwards;
        }
        #stage-skip-button {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.4);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 50;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
        }
        #stage-skip-button:hover {
            background-color: rgba(0,0,0,0.7);
            transform: scale(1.1);
        }
        #animal-selection-modal .modal-content {
            gap: 15px;
        }
        #animal-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            width: 100%;
            margin-top: 10px;
        }
        .animal-select-icon {
            font-size: 2em;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        .animal-select-icon:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .final-grade {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 0 0 20px currentColor;
        }
        .grade-S { color: var(--gold-color); }
        .grade-A { color: var(--purple-glow); }
        .grade-B { color: var(--blue-glow); }
        .grade-C { color: var(--green-glow); }
        .grade-D { color: var(--secondary-text); }

    </style>
</head>
<body>
<div class="game-wrapper">
    <div id="start-screen">
        <h1>Zodiac PowerCard</h1>
        <div id="animal-showcase" class="animal-showcase"></div>
        <button id="start-button">Í≤åÏûÑ ÏãúÏûë</button>
        <div class="copyright">Copyright 2025 @ k-ezst. Licensed under Apache 2.0</div>
    </div>
    <div id="game-container" class="game-container">
        </div>
    <div id="tooltip-modal" class="modal">
        <div class="modal-content">
            <h2 id="tooltip-name"></h2>
            <div id="tooltip-icon"></div>
            <p id="tooltip-desc"></p>
            <button id="tooltip-close-btn" class="action-button">Îã´Í∏∞</button>
        </div>
    </div>
    <div id="animal-selection-modal" class="modal">
        <div class="modal-content">
            <h2>ÎèôÎ¨º ÏÑ†ÌÉù</h2>
            <p>Ìö®Í≥ºÎ•º Ï†ÅÏö©Ìï† ÎèôÎ¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
            <div id="animal-selection-grid"></div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const startScreen = document.getElementById('start-screen');
    const startButton = document.getElementById('start-button');
    const gameContainer = document.getElementById('game-container');
    const tooltipModal = document.getElementById('tooltip-modal');
    const animalSelectionModal = document.getElementById('animal-selection-modal');
    const animalShowcaseEl = document.getElementById('animal-showcase');

    let gameBoardEl, scoreProgressFillEl, currentScoreTextEl, targetScoreTextEl, movesDisplayEl, goldDisplayEl, effectsLayer, stageEndScreen, targetMarkerEl, targetTextContainerEl, relicSelectionScreen;
    let board = [], score = 0, movesLeft = 0, stage = 1, targetScore = 0, gold = 0;
    let totalAccumulatedScore = 0;
    let draggedCardEl = null, dragClone = null, isProcessing = false, isDragging = false;
    let lastHoveredIndex = -1;
    let animationFrameId = null;
    let relics = {};
    let tempBuffs = {};
    let currentBoss = null;
    let activeAnimals = [];
    let initialMoves = 10;
    let targetReached = false;
    let animalSelectionCallback = null;

    // [MODIFIED] ÎìúÎûòÍ∑∏ ÏÑ±Îä• ÏµúÏ†ÅÌôî Î∞è Í∏∞Ï§ÄÏ†ê Î≥ÄÍ≤ΩÏùÑ ÏúÑÌïú Î≥ÄÏàò Ï∂îÍ∞Ä
    let currentX, currentY;
    let dragStartRect = null;
    let boardRect = null;
    let cardSize = { width: 0, height: 0 };
    let gapSize = { x: 0, y: 0 };
    let paddingSize = { x: 0, y: 0 };

    const getEmojiUrl = (emoji) => {
        if (typeof emoji !== 'string' || emoji.length === 0) {
            console.error("getEmojiUrl received an invalid value:", emoji);
            return 'https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/2753.svg'; 
        }
        const code = [...emoji].map(char => char.codePointAt(0).toString(16)).join('-');
        return `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/${code}.svg`;
    };

    const ALL_ANIMALS = ['üê≠', 'üêÆ', 'üêØ', 'üê∞', 'üê≤', 'üêç', 'üê¥', 'üêè', 'üêµ', 'üêî', 'üê∂', 'üê∑'];
    const ROWS = 5, COLS = 5;

    const allItems = {
        moreMoves1: { name: "ÌÜ†ÎÅºÏùò ÏßÄÌòú I", desc: "Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ Ïù¥Îèô ÌöüÏàò +2", cost: 100, effect: () => tempBuffs.extraMoves = (tempBuffs.extraMoves || 0) + 2 },
        moreMoves2: { name: "ÌÜ†ÎÅºÏùò ÏßÄÌòú II", desc: "Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ Ïù¥Îèô ÌöüÏàò +4", cost: 250, effect: () => tempBuffs.extraMoves = (tempBuffs.extraMoves || 0) + 4 },
        goldBoost1: { name: "ÎèºÏßÄÏùò Ï†ÄÍ∏àÌÜµ I", desc: "Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ ÏµúÏ¢Ö Í≥®Îìú 15% Ï¶ùÍ∞Ä", cost: 180, effect: () => tempBuffs.goldMultiplier = (tempBuffs.goldMultiplier || 1) * 1.15 },
        goldBoost2: { name: "ÎèºÏßÄÏùò Ï†ÄÍ∏àÌÜµ II", desc: "Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ ÏµúÏ¢Ö Í≥®Îìú 30% Ï¶ùÍ∞Ä", cost: 400, effect: () => tempBuffs.goldMultiplier = (tempBuffs.goldMultiplier || 1) * 1.30 },
        setNine: { name: "Ïà´Ïûê Ï°∞ÏûëÍ∏∞", desc: "Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú, Ïπ¥Îìú ÌïòÎÇòÎ•º 9Î°ú ÏãúÏûë", cost: 150, effect: () => tempBuffs.setNine = true },
        upgradeCard: { name: "Î≤ºÎùΩ", desc: `Î¨¥ÏûëÏúÑ Ïπ¥Îìú 3Í∞úÏùò Ïà´ÏûêÎ•º +${5 + stage}`, cost: 200, instant: true, effect: () => { for(let i=0; i<3; i++) { const idx = Math.floor(Math.random()*25); if(board?.[idx]?.type==='normal') board[idx].number += (5 + stage); } updateView(); } },
        boardReroll: { name: "ÏõêÏà≠Ïù¥Ïùò ÏÜêÍ∏∏", desc: "Ï¶âÏãú Í∞ÄÏû• ÎÇÆÏùÄ Ïà´Ïûê Ïπ¥Îìú 5Í∞ú ÍµêÏ≤¥", cost: 80, instant: true, effect: () => {
            const indices = board.map((c, i) => ({...c, index: i})).filter(c => c?.type === 'normal').sort((a, b) => a.number - b.number).slice(0, 5).map(c => c.index);
            indices.forEach(i => { board[i] = generateRandomCardData(stage, true); });
            updateView();
        }},
        addMoves: { name: "ÏãúÍ∞Ñ ÏôúÍ≥°", desc: "Ï¶âÏãú Ïù¥Îèô ÌöüÏàò +3", cost: 250, instant: true, effect: () => { movesLeft += 3; initialMoves += 3; triggerUiUpdateEffect(movesDisplayEl); updateView(); } },
        scoreSpike: { name: "ÏùºÌôïÏ≤úÍ∏à", desc: `Ï¶âÏãú Ï†êÏàò +${500 + stage * 20}`, cost: 350, instant: true, effect: () => { score += (500 + stage * 20); updateView(); } },
        cardEnchant: { name: "Ïö©Ïùò Ïà®Í≤∞", desc: `Í∞ÄÏû• ÎÜíÏùÄ Ïà´Ïûê Ïπ¥Îìú ÌïòÎÇòÏóê +${20 + stage * 2}`, cost: 220, instant: true, effect: () => {
            let maxIdx = -1, maxNum = -1;
            board.forEach((c, i) => { if(c && c.type === 'normal' && c.number > maxNum) { maxNum = c.number; maxIdx = i; } });
            if(maxIdx !== -1) board[maxIdx].number += (20 + stage * 2);
            updateView();
        }},
        curseRemoval: { name: "Ï†ïÌôîÏùò Î¨ºÏïΩ", desc: "Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏùò Ï†ÄÏ£º Ïπ¥Îìú ÌïòÎÇòÎ•º Ï¶âÏãú Ï†úÍ±∞", cost: 300, instant: true, effect: () => {
            const cursedIdx = board.findIndex(c => c?.type === 'cursed');
            if (cursedIdx !== -1) {
                const cardEl = gameBoardEl.children[cursedIdx];
                if (cardEl) {
                    // [MODIFIED] Î≥¥Ïä§ Ïπ¥Îìú ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
                    cardEl.classList.add('cursed-destroy');
                    createShatterEffect(cursedIdx);
                    board[cursedIdx] = null;
                }
                
                setTimeout(() => {
                    if (currentBoss) currentBoss.remainingGoal--;
                    board[cursedIdx] = generateRandomCardData(stage, true);
                    updateView();
                }, 500);
            }
        }},
        doubleNextScore: { name: "Ï¶ùÌè≠Í∏∞", desc: "Îã§Ïùå ÏΩ§Î≥¥ Ï†êÏàòÎ•º 2Î∞∞Î°ú ÌöçÎìù (1Ìöå)", cost: 180, effect: () => tempBuffs.doubleNextScore = true },
        stageGoldBoost: { name: "Ìô©Í∏à ÎÇòÏπ®Î∞ò", desc: "Ïù¥Î≤à Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú ÏñªÎäî Î™®Îì† Í≥®Îìú +20%", cost: 220, effect: () => tempBuffs.stageGoldBoost = (tempBuffs.stageGoldBoost || 1) * 1.2 },
        guaranteedAnimal: { name: "ÎèôÎ¨ºÏùò Î∂ÄÎ¶Ñ", desc: "Îã§Ïùå 3Í∞úÏùò Ïπ¥ÎìúÎ•º ÏßÄÏ†ïÌïú ÎèôÎ¨ºÎ°ú ÏÉùÏÑ±", cost: 120, effect: () => {
            showAnimalSelectionModal((animal) => {
                tempBuffs.guaranteedAnimal = animal;
                tempBuffs.guaranteedAnimalCount = 3;
            });
        }},
        cardRemoval: { name: "Î∏îÎûôÌôÄ", desc: "Í∞ÄÏû• ÎÇÆÏùÄ Ïà´Ïûê Ïπ¥Îìú ÌïòÎÇòÎ•º Î≥¥ÎìúÏóêÏÑú Ï†úÍ±∞", cost: 70, instant: true, effect: () => {
            let minIdx = -1, minNum = Infinity;
            board.forEach((c, i) => { if(c && c.type === 'normal' && c.number < minNum) { minNum = c.number; minIdx = i; } });
            if(minIdx !== -1) { board[minIdx] = null; fillEmptyCells(); }
        }},
        rerollShop: { name: "ÏÉàÎ°úÍ≥†Ïπ®", desc: "ÏÉÅÏ†êÏùò ÏïÑÏù¥ÌÖú Î™©Î°ùÏùÑ Ï¶âÏãú Î≥ÄÍ≤ΩÌï©ÎãàÎã§.", cost: 50, instant: true, effect: () => { gold -= 50; document.getElementById('shop-gold').textContent = gold; populateShop(); } },
        comboStarter: { name: "ÏΩ§Î≥¥ Ïä§ÌÉÄÌÑ∞", desc: "Î¨¥ÏûëÏúÑÎ°ú Ïù∏Ï†ëÌïú 3Í∞ú Ïπ¥ÎìúÎ•º Í∞ôÏùÄ ÎèôÎ¨ºÎ°ú Î≥ÄÍ≤Ω", cost: 150, instant: true, effect: () => {
            const startIndex = Math.floor(Math.random() * 25);
            const neighbors = getNeighborIndices([startIndex], false);
            if (neighbors.length >= 2) {
                const targetAnimal = activeAnimals[Math.floor(Math.random() * activeAnimals.length)];
                if(board[startIndex]) board[startIndex].animal = targetAnimal;
                if(board[neighbors[0]]) board[neighbors[0]].animal = targetAnimal;
                if(board[neighbors[1]]) board[neighbors[1]].animal = targetAnimal;
                updateView();
            }
        }},
        numberSwap: { name: "Ïà´Ïûê ÍµêÌôòÍ∏∞", desc: "Í∞ÄÏû• ÎÜíÏùÄ Ïπ¥ÎìúÏôÄ Í∞ÄÏû• ÎÇÆÏùÄ Ïπ¥ÎìúÏùò Ïà´ÏûêÎ•º ÍµêÌôò", cost: 180, instant: true, effect: () => {
             let minIdx = -1, minNum = Infinity, maxIdx = -1, maxNum = -1;
             board.forEach((c, i) => { 
                 if(c?.type === 'normal') {
                     if(c.number < minNum) { minNum = c.number; minIdx = i; }
                     if(c.number > maxNum) { maxNum = c.number; maxIdx = i; }
                 }
             });
             if(minIdx !== -1 && maxIdx !== -1) {
                 [board[minIdx].number, board[maxIdx].number] = [board[maxIdx].number, board[minIdx].number];
                 updateView();
             }
        }},
        goldenTouch: { name: "Ìô©Í∏àÏùò ÏÜêÍ∏∏", desc: "Î¨¥ÏûëÏúÑ Ïπ¥Îìú ÌïòÎÇòÎ•º Ìô©Í∏à Ïπ¥ÎìúÎ°ú Î≥ÄÍ≤Ω", cost: 400, instant: true, effect: () => {
            const normalCards = board.map((c,i) => ({...c, index: i})).filter(c => c.type === 'normal');
            if(normalCards.length > 0) {
                const randIdx = normalCards[Math.floor(Math.random() * normalCards.length)].index;
                board[randIdx].isGold = true;
                updateView();
            }
        }},
        interest: { name: "Ïù¥ÏûêÏùò Ï¶êÍ±∞ÏõÄ", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïãú Î≥¥Ïú† Í≥®ÎìúÏùò 5%Î•º Ï∂îÍ∞Ä ÌöçÎìù", cost: 150, effect: () => tempBuffs.interest = true },
    };
    
    const RARITY_KR = { Common: 'ÏùºÎ∞ò', Advanced: 'Í≥†Í∏â', Rare: 'Ìù¨Í∑Ä', Legendary: 'Ï†ÑÏÑ§' };
    const allRelics = {
        miceCrumbs: { rarity: 'Common', name: "Ï•êÏùò Î∂ÄÏä§Îü¨Í∏∞", icon: "üßÄ", desc: "3-ÏΩ§Î≥¥Í∞Ä 10%Ïùò Ï∂îÍ∞Ä Ï†êÏàòÎ•º ÏñªÏäµÎãàÎã§." },
        oxFortitude: { rarity: 'Common', name: "ÏÜåÏùò ÎöùÏã¨", icon: "üí™", desc: "Îß§ Ïä§ÌÖåÏù¥ÏßÄÏùò Ï≤´ Ïù¥ÎèôÏùÄ ÌöüÏàòÎ•º ÏÜåÎ™®ÌïòÏßÄ ÏïäÏäµÎãàÎã§." },
        rabbitHop: { rarity: 'Common', name: "ÌÜ†ÎÅºÏùò ÎúÄÎ∞ïÏßà", icon: "üëü", desc: "ÏùºÏπòÌïòÏßÄ ÏïäÎäî Ïπ¥ÎìúÎ•º ÍµêÌôòÌï† Îïå 10% ÌôïÎ•†Î°ú Ïù¥Îèô ÌöüÏàòÎ•º ÏÜåÎ™®ÌïòÏßÄ ÏïäÏäµÎãàÎã§." },
        snakeShedSkin: { rarity: 'Advanced', name: "Î±ÄÏùò ÌóàÎ¨º", icon: "üêç", desc: "Ïä§ÌÖåÏù¥ÏßÄ Îãπ Ìïú Î≤à, Ïù¥Îèô ÌöüÏàòÍ∞Ä 0Ïù¥ ÎêòÎ©¥ 2Î•º Ï∂îÍ∞ÄÎ°ú ÏñªÏäµÎãàÎã§." },
        sheepWool: { rarity: 'Advanced', name: "ÏñëÏùò ÌÑ∏Î≠âÏπò", icon: "üêë", desc: "Ïπ¥Îìú ÏÉùÏÑ± Ïãú 5% ÌôïÎ•†Î°ú Î≥¥ÎìúÏóêÏÑú Í∞ÄÏû• ÎÜíÏùÄ Ïà´Ïûê Ïπ¥ÎìúÏùò Î≥µÏÇ¨Î≥∏Ïù¥ Îê©ÎãàÎã§." },
        roosterPerch: { rarity: 'Rare', name: "Îã≠Ïùò ÌöÉÎåÄ", icon: "üêì", desc: `ÌÑ¥ Ï¢ÖÎ£å Ïãú, Î≥¥ÎìúÏóêÏÑú Í∞ÄÏû• ÎÜíÏùÄ Ïà´Ïûê Ïπ¥Îìú ÌïòÎÇòÍ∞Ä +${5 + Math.floor(stage / 5)}Ïùò Ï†êÏàòÎ•º ÏñªÏäµÎãàÎã§.` },
        piggyBank: { rarity: 'Rare', name: "ÏÉÅÏù∏Ïùò ÎèºÏßÄ Ï†ÄÍ∏àÌÜµ", icon: "üêñ", desc: "ÏÉÅÏ†êÏùò ÏïÑÏù¥ÌÖú Í∞ÄÍ≤©Ïù¥ ÏòÅÍµ¨Ï†ÅÏúºÎ°ú 10% Ìï†Ïù∏Îê©ÎãàÎã§." },
        dragonsOrb: { rarity: 'Rare', name: "Ïö©Ïùò Ïó¨ÏùòÏ£º", icon: "üîÆ", desc: "Î™®Îì† ÎèôÎ¨ºÏùò Í≥†Ïú† ÏΩ§Î≥¥ Ìö®Í≥ºÍ∞Ä 25% Ï¶ùÌè≠Îê©ÎãàÎã§." },
        zodiacBlessing: { rarity: 'Legendary', name: "Ïã≠Ïù¥ÏßÄÏã†Ïùò Í∞ÄÌò∏", icon: "üåü", desc: "Î™®Îì† ÏΩ§Î≥¥Í∞Ä Ï†êÏàò Í≥ÑÏÇ∞ Ïãú +1 Í∏∏Ïù¥Î°ú Ï∑®Í∏âÎê©ÎãàÎã§." },
        wheelOfTime: { rarity: 'Legendary', name: "ÏãúÍ∞ÑÏùò ÏàòÎ†àÎ∞îÌÄ¥", icon: "‚ò∏Ô∏è", desc: "5Î≤à Ïù¥ÎèôÌï† ÎïåÎßàÎã§ Ïù¥Îèô ÌöüÏàò 1ÏùÑ ÎêòÎèåÎ†§Î∞õÏäµÎãàÎã§." },
        alchemistSecret: { rarity: 'Legendary', name: "Ïó∞Í∏àÏà†ÏÇ¨Ïùò ÎπÑÍ∏â", icon: "‚öóÔ∏è", desc: "Ïà´ÏûêÍ∞Ä 100 Ïù¥ÏÉÅÏù∏ Ïπ¥Îìú Îëê Í∞úÎ•º Ìï©ÏπòÎ©¥, 100Í≥®ÎìúÎ•º Ï£ºÎäî Ìô©Í∏à Ïπ¥ÎìúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§." },
        ancientCalendar: { rarity: 'Common', name: "Ïò§ÎûòÎêú Îã¨Î†•", icon: "üóìÔ∏è", desc: "12Î≤à Ïù¥ÎèôÌï† ÎïåÎßàÎã§, Î¨¥ÏûëÏúÑ Ïπ¥Îìú ÌïòÎÇòÍ∞Ä +12." },
        brokenCompass: { rarity: 'Common', name: "Í≥†Ïû•ÎÇú ÎÇòÏπ®Î∞ò", icon: "üß≠", desc: "Ïπ¥Îìú ÍµêÌôò Ïãú, 5% ÌôïÎ•†Î°ú Î¨¥ÏûëÏúÑ ÎèôÎ¨ºÎ°ú Î≥ÄÍ≤ΩÎê©ÎãàÎã§." },
        smallPouch: { rarity: 'Common', name: "ÏûëÏùÄ Ï£ºÎ®∏Îãà", icon: "üëù", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú 10Í≥®ÎìúÎ•º Í∞ÄÏßÄÍ≥† ÏãúÏûëÌï©ÎãàÎã§." },
        whetstone: { rarity: 'Common', name: "Ïà´Îèå", icon: "üî™", desc: "Ïπ¥Îìú Ìï©Ï≤¥ Ïãú, 10% ÌôïÎ•†Î°ú Í≤∞Í≥ºÍ∞í +10." },
        fourLeafClover: { rarity: 'Common', name: "ÎÑ§ÏûéÌÅ¥Î°úÎ≤Ñ", icon: "üçÄ", desc: "Î™®Îì† ÌôïÎ•† Í∏∞Î∞ò Ïú†Î¨ºÏùò Î∞úÎèô ÌôïÎ•†Ïù¥ +2% Ï¶ùÍ∞ÄÌï©ÎãàÎã§." },
        trainingWeight: { rarity: 'Common', name: "ÏàòÎ†®Ïö© Ï∂î", icon: "üèãÔ∏è", desc: "Ïù¥Îèô ÌöüÏàòÍ∞Ä 5 Îçî ÎßéÏßÄÎßå, Î™©Ìëú Ï†êÏàòÍ∞Ä 10% Ï¶ùÍ∞ÄÌï©ÎãàÎã§." },
        stickyGlove: { rarity: 'Common', name: "ÎÅàÎÅàÏù¥ Ïû•Í∞ë", icon: "üß§", desc: "Ïπ¥Îìú ÍµêÌôò ÎπÑÏö©Ïù¥ 10% ÌôïÎ•†Î°ú 0Ïù¥ Îê©ÎãàÎã§." },
        tinyAnvil: { rarity: 'Common', name: "ÏûëÏùÄ Î™®Î£®", icon: "üî®", desc: "ÌÑ¥ Ï¢ÖÎ£å Ïãú, Í∞ÄÏû• ÎÇÆÏùÄ Ïπ¥Îìú ÌïòÎÇòÏùò Ïà´ÏûêÍ∞Ä +1." },
        miceCunning: { rarity: 'Advanced', name: "Ï•êÏùò ÍµêÌôúÌï®", icon: "üßê", desc: "ÏΩ§Î≥¥Î°ú Ïπ¥ÎìúÎ•º Ï†úÍ±∞Ìï† ÎïåÎßàÎã§, 10% ÌôïÎ•†Î°ú 1Í≥®Îìú ÌöçÎìù." },
        oxPerseverance: { rarity: 'Advanced', name: "ÏÜåÏùò Ïù∏ÎÇ¥", icon: "üßò", desc: "Ïù¥Îèô ÌöüÏàòÍ∞Ä 3 Ïù¥ÌïòÏùº Îïå, ÏΩ§Î≥¥ Ï†êÏàò +15%." },
        tigersClaw: { rarity: 'Advanced', name: "Ìò∏ÎûëÏù¥ Î∞úÌÜ±", icon: "üêÖ", desc: "Ìò∏ÎûëÏù¥ ÏΩ§Î≥¥Í∞Ä Î∞úÏÉùÌïòÎ©¥, Î≥¥ÎìúÏóêÏÑú Í∞ÄÏû• ÎÇÆÏùÄ Ïà´Ïûê Ïπ¥Îìú ÌïòÎÇòÎ•º Ï†úÍ±∞Ìï©ÎãàÎã§." },
        luckyFoot: { rarity: 'Advanced', name: "ÌñâÏö¥Ïùò ÌÜ†ÎÅºÎ∞ú", icon: "üêá", desc: "7-ÏΩ§Î≥¥ Ïù¥ÏÉÅ Î∞úÏÉù Ïãú, Ïù¥Îèô ÌöüÏàò +1." },
        dragonsMight: { rarity: 'Advanced', name: "Ïö©Ïùò ÏúÑÏóÑ", icon: "üêâ", desc: "Ïö© ÏΩ§Î≥¥ Î∞úÏÉù Ïãú, Ìï¥Îãπ Ïó¥Ïùò Î™®Îì† Ïπ¥ÎìúÍ∞Ä +5." },
        stampede: { rarity: 'Advanced', name: "ÎßêÏùò ÎèåÏßÑ", icon: "üêé", desc: "Îßê ÏΩ§Î≥¥ Î∞úÏÉù Ïãú, Î≥¥ÎìúÏùò Î™®Îì† Îßê Ïπ¥ÎìúÍ∞Ä +3." },
        flockTogether: { rarity: 'Advanced', name: "ÏñëÎñº", icon: "üêë", desc: "Ïñë ÏΩ§Î≥¥Ïóê Ìè¨Ìï®Îêú Ïπ¥Îìú ÌïòÎÇòÎãπ ÏµúÏ¢Ö Ï†êÏàò +2%." },
        mischief: { rarity: 'Advanced', name: "ÏõêÏà≠Ïù¥Ïùò Ïû•ÎÇú", icon: "üêí", desc: "Ïπ¥Îìú ÍµêÌôò Ïãú, 15% ÌôïÎ•†Î°ú Îëê Ïπ¥Îìú Î™®Îëê Ïà´ÏûêÍ∞Ä +5." },
        morningCall: { rarity: 'Advanced', name: "Îã≠Ïùò Ïô∏Ïπ®", icon: "üêî", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú, Î™®Îì† Ïπ¥ÎìúÏùò Ïà´ÏûêÍ∞Ä +1." },
        loyalty: { rarity: 'Advanced', name: "Í∞úÏùò Ï∂©ÏÑ±Ïã¨", icon: "üêï", desc: "Í∞ôÏùÄ ÎèôÎ¨ºÏùÑ Ïó∞ÏÜçÏúºÎ°ú 3Î≤à Ìï©ÏπòÎ©¥, Ïù¥Îèô ÌöüÏàò +1." },
        gluttony: { rarity: 'Advanced', name: "ÎèºÏßÄÏùò ÏãùÌÉê", icon: "üçî", desc: "ÏΩ§Î≥¥Î°ú ÏñªÎäî Ï†êÏàòÍ∞Ä 1000ÏùÑ ÎÑòÏùÑ ÎïåÎßàÎã§, 10Í≥®ÎìúÎ•º Ï∂îÍ∞ÄÎ°ú ÌöçÎìù." },
        magnifyingGlass: { rarity: 'Advanced', name: "ÎèãÎ≥¥Í∏∞", icon: "üîé", desc: "ÏÉÅÏ†êÏóê ÏïÑÏù¥ÌÖúÏù¥ ÌïòÎÇò Îçî Îì±Ïû•Ìï©ÎãàÎã§." },
        plagueSpread: { rarity: 'Rare', name: "Ïó≠Î≥ë ÌôïÏÇ∞", icon: "‚ò£Ô∏è", desc: "Ï•ê ÏΩ§Î≥¥Í∞Ä Ï£ºÎ≥Ä Ïπ¥Îìú 1Í∞úÏùò Ïà´ÏûêÎ•º 5% Í∞êÏÜåÏãúÌÇ§Í≥†, Í∑∏ÎßåÌÅº Ï•ê Ïπ¥ÎìúÏóê ÎçîÌï©ÎãàÎã§." },
        unshakable: { rarity: 'Rare', name: "Î∂ÄÎèôÏã¨", icon: "üóø", desc: "ÏÜå Ïπ¥ÎìúÎäî Îã§Î•∏ Ïπ¥ÎìúÏùò Ìö®Í≥º(Ïà´Ïûê Í∞êÏÜå Îì±)Ïóê Î©¥Ïó≠Ïù¥ Îê©ÎãàÎã§." },
        burrow: { rarity: 'Rare', name: "Íµ¥ ÌååÍ∏∞", icon: "üï≥Ô∏è", desc: "ÌÜ†ÎÅº Ïπ¥ÎìúÎ•º Ìï©Ïπ† Îïå, 20% ÌôïÎ•†Î°ú Ïà´ÏûêÍ∞Ä Îëê Î∞∞Í∞Ä Îê©ÎãàÎã§." },
        venomousTouch: { rarity: 'Rare', name: "ÎèÖÏÇ¨Ïùò ÏÜêÍ∏∏", icon: "‚ò†Ô∏è", desc: "Î±Ä ÏΩ§Î≥¥Í∞Ä Î∞úÏÉùÌïòÎ©¥, Îã§Ïùå 3Î≤àÏùò Ïù¥Îèô ÎèôÏïà Ìï©Ï≥êÏßÄÎäî Ïπ¥ÎìúÎì§Ïùò Í∏∞Î≥∏ Ï†êÏàòÍ∞Ä +10." },
        enduranceRun: { rarity: 'Rare', name: "Ïû•Í±∞Î¶¨ Í≤ΩÏ£º", icon: "üèá", desc: "10Î≤à Ïù¥ÎèôÌï† ÎïåÎßàÎã§, Í∞ÄÏû• ÎÇÆÏùÄ Ïà´Ïûê Ïπ¥Îìú ÌïòÎÇòÍ∞Ä +10." },
        peckingOrder: { rarity: 'Rare', name: "ÏÑúÏó¥ Ï†ïÎ¶¨", icon: "üëë", desc: "Îã≠ ÏΩ§Î≥¥Í∞Ä Î∞úÏÉùÌïòÎ©¥, Î≥¥ÎìúÏóêÏÑú Í∞ÄÏû• ÎÇÆÏùÄ Ïà´Ïûê Ïπ¥Îìú 2Í∞úÏùò ÏúÑÏπòÎ•º Î∞îÍøâÎãàÎã§." },
        guardDog: { rarity: 'Rare', name: "Í≤ΩÎπÑÍ≤¨", icon: "üõ°Ô∏è", desc: "Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú Î≥¥Ïä§Ïùò Ï†ÄÏ£ºÍ∞Ä 1Í∞ú Îçú ÏÉùÏÑ±Îê©ÎãàÎã§." },
        emergencyKit: { rarity: 'Rare', name: "ÎπÑÏÉÅ ÌÇ§Ìä∏", icon: "ü©π", desc: "Ïù¥Îèô ÌöüÏàòÍ∞Ä 1Ïùº Îïå, 50% ÌôïÎ•†Î°ú +2 Ïù¥Îèô ÌöüÏàòÎ•º ÏñªÏäµÎãàÎã§." },
        couponBook: { rarity: 'Rare', name: "Ïø†Ìè∞Î∂Å", icon: "üéüÔ∏è", desc: "ÏÉÅÏ†ê ÏïÑÏù¥ÌÖúÏùÑ 3Í∞ú Íµ¨Îß§Ìï† ÎïåÎßàÎã§, Îã§Ïùå Íµ¨Îß§Îäî 50% Ìï†Ïù∏Îê©ÎãàÎã§." },
        recyclingBin: { rarity: 'Rare', name: "Ïû¨ÌôúÏö© ÏÉÅÏûê", icon: "‚ôªÔ∏è", desc: "Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú ÎÇ®ÏùÄ Ïπ¥Îìú Ïà´ÏûêÏùò 1%Î•º Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ï†êÏàòÎ°ú Í∞ÄÏ†∏Í∞ëÎãàÎã§ (ÏµúÎåÄ 1000)." },
        shedSkinOnceMore: { rarity: 'Rare', name: "Îëê Î≤àÏß∏ ÌóàÎ¨º", icon: "üêç", desc: "'Î±ÄÏùò ÌóàÎ¨º' Ïú†Î¨ºÏù¥ Ïä§ÌÖåÏù¥ÏßÄÎãπ Îëê Î≤à Î∞úÎèôÌï©ÎãàÎã§." },
        kingOfTheMountain: { rarity: 'Legendary', name: "ÏÇ∞Ïùò Ïôï", icon: "üèîÔ∏è", desc: "Î≥¥ÎìúÏóê Ìò∏ÎûëÏù¥ Ïπ¥ÎìúÍ∞Ä 5Í∞ú Ïù¥ÏÉÅÏù¥Î©¥ Î™®Îì† ÏΩ§Î≥¥ Ï†êÏàò +10%." },
        celestialReign: { rarity: 'Legendary', name: "Ï≤úÏÉÅÏùò ÏßÄÎ∞∞", icon: "üåå", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú, Ïö© Ïπ¥ÎìúÎäî Ìï≠ÏÉÅ Îã§Î•∏ Ïπ¥ÎìúÎ≥¥Îã§ ÎÜíÏùÄ Ïà´ÏûêÎ°ú ÏãúÏûëÌï©ÎãàÎã§." },
        goldenFleece: { rarity: 'Legendary', name: "Ìô©Í∏à ÏñëÌÑ∏", icon: "‚ú®", desc: "Ïñë Ïπ¥ÎìúÎ•º Ìè¨Ìï®Ìïú 5-ÏΩ§Î≥¥ Ïù¥ÏÉÅ Î∞úÏÉù Ïãú, 100Í≥®ÎìúÎ•º ÌöçÎìùÌï©ÎãàÎã§." },
        trickstersLuck: { rarity: 'Legendary', name: "ÏÇ¨Í∏∞ÍæºÏùò ÌñâÏö¥", icon: "üé≤", desc: "ÏÉÅÏ†êÏóêÏÑú ÏïÑÏù¥ÌÖú Íµ¨Îß§ Ïãú, 10% ÌôïÎ•†Î°ú Í≥®ÎìúÎ•º ÏÜåÎ™®ÌïòÏßÄ ÏïäÏäµÎãàÎã§." },
        yearOfFortune: { rarity: 'Legendary', name: "ÌñâÏö¥Ïùò Ìï¥", icon: "üßß", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïãú Î∞õÎäî Í≥®ÎìúÍ∞Ä 25% Ï¶ùÍ∞ÄÌï©ÎãàÎã§." },
        scholarStone: { rarity: 'Legendary', name: "ÌïôÏûêÏùò Îèå", icon: "üíé", desc: "Ïπ¥ÎìúÏùò Ïà´ÏûêÍ∞Ä 1000ÏùÑ ÎÑòÏùÑ ÎïåÎßàÎã§, ÏòÅÍµ¨Ï†ÅÏúºÎ°ú Î™®Îì† ÏΩ§Î≥¥ Ï†êÏàò +1%." },
        crownOfGreed: { rarity: 'Legendary', name: "ÌÉêÏöïÏùò ÏôïÍ¥Ä", icon: "üëë", desc: "Í≥®ÎìúÎ•º 500 ÏÜåÎ™®Ìï† ÎïåÎßàÎã§, ÏµúÎåÄ Ïù¥Îèô ÌöüÏàò +1." },
        chaosOrb: { rarity: 'Legendary', name: "ÌòºÎèàÏùò Î≥¥Ï£º", icon: "üåÄ", desc: "Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë Ïãú, Î™®Îì† Ïπ¥ÎìúÍ∞Ä Î¨¥ÏûëÏúÑÎ°ú Î≥ÄÍ≤ΩÎêòÏßÄÎßå, Î™©Ìëú Ï†êÏàòÍ∞Ä 20% Í∞êÏÜåÌï©ÎãàÎã§." }
    };

    const defaultBoss = {
        name: "Ï†ÄÏ£ºÎ∞õÏùÄ ÏÑùÏÉÅ", goalText: "Ï£ºÎ≥ÄÏóêÏÑú ÏΩ§Î≥¥Î•º ÏùºÏúºÏºú ÏÑùÏÉÅ 3Í∞úÎ•º ÌååÍ¥¥ÌïòÏÑ∏Ïöî!", goalValue: 3,
        setup: (b) => { 
            let count = 3;
            if(relics.guardDog) count--;
            let p = 0; 
            while(p < count) { 
                const i = Math.floor(Math.random() * b.length); 
                if(b[i]?.type === 'normal') { b[i] = { type: 'cursed' }; p++; } 
            } 
        },
        onCombo: (combo, b) => {
            let destroyedIndices = [];
            getNeighborIndices(combo.indices, true).forEach(i => {
                if (b[i]?.type === 'cursed') {
                    destroyedIndices.push(i);
                }
            });
            if (destroyedIndices.length > 0) {
                currentBoss.remainingGoal -= destroyedIndices.length;
                destroyedIndices.forEach(i => {
                    const cardEl = gameBoardEl.children[i];
                    if (cardEl) {
                        // [MODIFIED] Î≥¥Ïä§ Ïπ¥Îìú ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
                        cardEl.classList.add('cursed-destroy');
                        createShatterEffect(i);
                        b[i] = null; 
                    }
                });
                
                setTimeout(() => {
                    destroyedIndices.forEach(i => {
                        b[i] = generateRandomCardData(stage, true);
                    });
                    updateView();
                }, 500);
            }
        }
    };

    function setupStartScreen() {
        animalShowcaseEl.innerHTML = ALL_ANIMALS.map(animal => `<span><img src="${getEmojiUrl(animal)}" alt="${animal}"></span>`).join('');
    }

    startButton.addEventListener('click', () => {
        startScreen.style.opacity = '0';
        setTimeout(() => {
            startScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            setupGameUIAndListeners();
            initializeGame();
        }, 500);
    });

    function setupGameUIAndListeners() {
        gameContainer.innerHTML = `
            <header class="game-header">
                <div class="info-box"><h2>STAGE</h2><p id="stage">1</p></div>
                <div class="info-box-large">
                    <div class="progress-bar-bg">
                        <div id="score-progress-fill" class="progress-bar-fill">
                            <div class="progress-text-container">
                                <span id="current-score-text" class="progress-text"></span>
                            </div>
                        </div>
                        <div class="target-label">Target</div>
                        <div id="target-text-container" class="target-text-container"><span id="target-score-text">1000</span></div>
                        <div id="score-target-marker" class="progress-target-marker"></div>
                    </div>
                    <div class="header-stats-overlay">
                        <span id="moves-display" class="header-stat">Move 10 / 10</span>
                        <span id="gold-display" class="header-stat">üí∞ 0</span>
                    </div>
                </div>
            </header>
            <div id="animal-status-bar" class="status-bar"><h4>Ïù¥Î≤à Ïä§ÌÖåÏù¥ÏßÄ ÎèôÎ¨º</h4><div class="icon-container"></div></div>
            <div id="relics-display" class="status-bar"><h4>Ïú†Î¨º</h4><div id="relic-icons" class="icon-container"></div></div>
            <div class="game-board-wrapper">
                <div class="board-container">
                    <div id="game-board"></div>
                    <svg id="effects-layer"></svg>
                    <div id="html-effects-layer"></div>
                </div>
            </div>
            <button id="stage-skip-button" title="Ïä§ÌÖåÏù¥ÏßÄ Ïä§ÌÇµ">¬ª</button>
            <div id="stage-end-screen" style="display: none;">
                <div id="stage-end-content"></div>
            </div>
            <div id="relic-selection-screen" style="display: none;">
                 <div id="relic-selection-content"></div>
            </div>`;
        
        document.getElementById('effects-layer').innerHTML = `
            <defs>
                <linearGradient id="combo-gradient" gradientTransform="rotate(90)">
                    <stop offset="0%" stop-color="#fffde4" />
                    <stop offset="100%" stop-color="#ffd700" />
                </linearGradient>
                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur"></feGaussianBlur>
                    <feMerge>
                        <feMergeNode in="coloredBlur"></feMergeNode>
                        <feMergeNode in="SourceGraphic"></feMergeNode>
                    </feMerge>
                </filter>
            </defs>
        `;

        gameBoardEl = document.getElementById('game-board');
        scoreProgressFillEl = document.getElementById('score-progress-fill');
        currentScoreTextEl = document.getElementById('current-score-text');
        targetScoreTextEl = document.getElementById('target-score-text');
        movesDisplayEl = document.getElementById('moves-display');
        goldDisplayEl = document.getElementById('gold-display');
        targetMarkerEl = document.getElementById('score-target-marker');
        targetTextContainerEl = document.getElementById('target-text-container');
        effectsLayer = document.getElementById('effects-layer');
        stageEndScreen = document.getElementById('stage-end-screen');
        relicSelectionScreen = document.getElementById('relic-selection-screen');

        gameBoardEl.addEventListener('mousedown', handleDragStart, { passive: true });
        gameBoardEl.addEventListener('touchstart', handleDragStart, { passive: true });
        window.addEventListener('mousemove', handleDragMove, { passive: false });
        window.addEventListener('touchmove', handleDragMove, { passive: false });
        window.addEventListener('mouseup', handleDragEnd);
        window.addEventListener('touchend', handleDragEnd);

        tooltipModal.querySelector('#tooltip-close-btn').addEventListener('click', () => tooltipModal.classList.remove('show'));
        document.getElementById('relics-display').addEventListener('click', handleRelicIconClick);
        document.getElementById('stage-skip-button').addEventListener('click', () => checkStageEnd(true));
        animalSelectionModal.querySelector('#animal-selection-grid').addEventListener('click', handleAnimalSelection);
    }

    function initializeGame() {
        stage = 0; score = 0; gold = 0; relics = {}; tempBuffs = {}; totalAccumulatedScore = 0;
        gameBoardEl.innerHTML = '';
        board = [];
        for (let i = 0; i < ROWS * COLS; i++) {
            board.push(null);
            gameBoardEl.appendChild(createCardElement(i));
        }
        advanceToNextStage(true);
    }

    function advanceToNextStage(isFirstStage = false) {
        stageEndScreen.style.display = 'none';
        relicSelectionScreen.style.display = 'none';
        
        if (!isFirstStage) {
            stage++;
            showRelicSelectionScreen();
        } else {
            stage = 1;
            continueToNextStage();
        }
    }

    function continueToNextStage() {
        if (relics.recyclingBin && tempBuffs.recycledScore) {
            score = tempBuffs.recycledScore;
        } else {
            score = 0;
        }
        if (relics.smallPouch) {
            gold += 10;
        }

        targetReached = false;
        currentBoss = null;
        selectActiveAnimals();
        if (stage > 0 && stage % 3 === 0 && stage < 40) {
            currentBoss = { ...defaultBoss, remainingGoal: defaultBoss.goalValue };
        }
        
        const moveBonus = Math.floor(stage / 5);
        initialMoves = 10 + (tempBuffs.extraMoves || 0) + moveBonus;
        if(relics.trainingWeight) initialMoves += 5;

        movesLeft = initialMoves;
        if (relics.oxFortitude) tempBuffs.firstMoveUsed = false;
        if (relics.shedSkinOnceMore) tempBuffs.snakeSkinUsed = 0;
        else if (relics.snakeShedSkin) tempBuffs.snakeSkinUsed = false;

        targetScore = currentBoss ? 0 : Math.floor((1000 + (stage - 1) * 600) * Math.pow(1.04, stage - 1));
        
        if (relics.trainingWeight) targetScore = Math.floor(targetScore * 1.1);
        if (relics.chaosOrb) targetScore = Math.floor(targetScore * 0.8);

        isProcessing = false;
        for(let i=0; i<board.length; i++) { board[i] = generateRandomCardData(stage); }

        if (relics.chaosOrb) {
            board.forEach(card => {
                if(card) {
                    card.animal = ALL_ANIMALS[Math.floor(Math.random() * ALL_ANIMALS.length)];
                    card.number = Math.floor(Math.random() * 10) + 1;
                }
            });
        }
        if(relics.morningCall) {
            board.forEach(c => { if(c) c.number++; });
        }
        if(relics.celestialReign) {
            const maxNum = board.reduce((max, c) => c ? Math.max(max, c.number) : max, 0);
            board.forEach(c => { if(c?.animal === 'üê≤') c.number = maxNum + 5; });
        }

        if (tempBuffs.setNine) {
            const randomIndex = Math.floor(Math.random() * board.length);
            if(board[randomIndex]) board[randomIndex].number = 9;
        }
        if (currentBoss?.setup) { currentBoss.setup(board); }
        tempBuffs = {};
        updateView();
    }
    
    async function processTurn(fromIndex, toIndex, dragCloneForAnimation) {
        if (isProcessing || !board[fromIndex] || !board[toIndex] || board[fromIndex].type !== 'normal') {
            if(dragCloneForAnimation) {
                const fromEl = gameBoardEl.children[fromIndex];
                const fromRect = fromEl.getBoundingClientRect();
                dragCloneForAnimation.style.transition = 'left 0.3s ease-out, top 0.3s ease-out, transform 0.3s ease-out';
                dragCloneForAnimation.style.left = `${fromRect.left}px`;
                dragCloneForAnimation.style.top = `${fromRect.top}px`;
                dragCloneForAnimation.style.transform = `translate(0, 0)`;
                setTimeout(() => dragCloneForAnimation.remove(), 300);
            }
            if(draggedCardEl) draggedCardEl.classList.remove('placeholder');
            return;
        }
        
        if(board[toIndex].type !== 'normal') {
            const fromEl = gameBoardEl.children[fromIndex];
            const fromRect = fromEl.getBoundingClientRect();
            dragCloneForAnimation.style.transition = 'left 0.3s ease-out, top 0.3s ease-out, transform 0.3s ease-out';
            dragCloneForAnimation.style.left = `${fromRect.left}px`;
            dragCloneForAnimation.style.top = `${fromRect.top}px`;
            dragCloneForAnimation.style.transform = `translate(0, 0) scale(1)`;
            setTimeout(() => {
                dragCloneForAnimation?.remove();
                fromEl.classList.remove('placeholder');
            }, 300);
            return;
        }

        isProcessing = true;
        
        const fromData = board[fromIndex], toData = board[toIndex];
        
        if (fromData.animal === toData.animal) {
            if(dragCloneForAnimation) dragCloneForAnimation.remove();
            if (relics.oxFortitude && !tempBuffs.firstMoveUsed) { tempBuffs.firstMoveUsed = true; } else { movesLeft--; triggerUiUpdateEffect(movesDisplayEl); }
            toData.number += fromData.number;
            if (relics.whetstone && Math.random() < 0.1) toData.number += 10;
            if (relics.alchemistSecret && fromData.number >= 100 && toData.number >= 100) toData.isGold = true;
            if (relics.burrow && fromData.animal === 'üê∞' && Math.random() < 0.2) toData.number *= 2;
            board[fromIndex] = generateRandomCardData(stage, true);
            updateView();
        } 
        else {
            let moveCosted = true;
            let cloverChance = relics.fourLeafClover ? 0.02 : 0;
            if (relics.oxFortitude && !tempBuffs.firstMoveUsed) { tempBuffs.firstMoveUsed = true; moveCosted = false; }
            else if (relics.rabbitHop && Math.random() < (0.1 + cloverChance)) { showFloatingText("Free Move!", fromIndex, 'gimmick'); moveCosted = false; }
            else if (relics.stickyGlove && Math.random() < (0.1 + cloverChance)) { showFloatingText("Free Swap!", fromIndex, 'gimmick'); moveCosted = false; }
            
            if(moveCosted) { movesLeft--; triggerUiUpdateEffect(movesDisplayEl); }
            
            if (relics.mischief && Math.random() < (0.15 + cloverChance)) {
                fromData.number += 5;
                toData.number += 5;
            }
            if (relics.brokenCompass && Math.random() < (0.05 + cloverChance)) {
                fromData.animal = ALL_ANIMALS[Math.floor(Math.random() * ALL_ANIMALS.length)];
            }

            await animateDirectSwap(fromIndex, toIndex, dragCloneForAnimation);
            [board[fromIndex], board[toIndex]] = [board[toIndex], board[fromIndex]];
            updateView();
        }
        
        await new Promise(res => setTimeout(res, 50));
        let isChaining = true;
        while(isChaining) {
            const combos = findAllCombos();
            if (combos.length > 0) {
                await handleCombos(combos);
                await fillEmptyCells();
                updateView();
                await new Promise(res => setTimeout(res, 400));
            } else { isChaining = false; }
        }
        await applyRankEffects();
        
        if(relics.roosterPerch) {
            let maxIdx = -1, maxNum = -1;
            board.forEach((c, i) => { if(c?.type === 'normal' && c.number > maxNum) { maxNum = c.number; maxIdx = i; } });
            if(maxIdx !== -1) { 
                const bonus = 5 + Math.floor(stage / 5);
                board[maxIdx].number += bonus; 
                showFloatingText(`+${bonus}`, maxIdx, 'effect'); 
            }
        }
        if(relics.tinyAnvil) {
            let minIdx = -1, minNum = Infinity;
            board.forEach((c, i) => { if(c?.type === 'normal' && c.number < minNum) { minNum = c.number; minIdx = i; } });
            if(minIdx !== -1) { board[minIdx].number += 1; }
        }

        updateView();
        setTimeout(() => {
            const snakeShedSkinMax = relics.shedSkinOnceMore ? 2 : 1;
            if (movesLeft <= 0 || (currentBoss && currentBoss.remainingGoal <= 0)) {
                checkStageEnd();
            } else if (relics.snakeShedSkin && movesLeft <= 0 && (tempBuffs.snakeSkinUsed < snakeShedSkinMax || tempBuffs.snakeSkinUsed === false)) {
                movesLeft += 2; initialMoves += 2; triggerUiUpdateEffect(movesDisplayEl); showFloatingText("Î±ÄÏùò ÌóàÎ¨º!", 12, 'gimmick'); 
                tempBuffs.snakeSkinUsed = (tempBuffs.snakeSkinUsed || 0) + 1;
                isProcessing = false; updateView();
            } else {
                isProcessing = false;
            }
        }, 400);
    }

    function findAllCombos() {
        const visited = new Array(ROWS * COLS).fill(false), allCombos = [];
        for (let i = 0; i < board.length; i++) {
            if (visited[i] || !board[i] || board[i].type !== 'normal') continue;
            const cluster = [], q = [i], currentAnimal = board[i].animal;
            visited[i] = true;
            while (q.length > 0) {
                const curr = q.shift();
                cluster.push(curr);
                getNeighborIndices([curr], true).forEach(nIdx => {
                    if (!visited[nIdx] && board[nIdx]?.type === 'normal' && board[nIdx].animal === currentAnimal) {
                        visited[nIdx] = true; q.push(nIdx);
                    }
                });
            }
            if (cluster.length >= 3) allCombos.push({ animal: currentAnimal, indices: cluster.sort((a,b) => a-b) });
        }
        return allCombos;
    }

    async function handleCombos(combos) {
        let totalScoreFromCombos = 0;
        for (const combo of combos) {
            drawComboLines(combo);
            await new Promise(res => setTimeout(res, 500)); 
            const targetIndex = combo.indices[0];
            
            const targetEl = gameBoardEl.children[targetIndex];
            if (targetEl) {
                targetEl.classList.add('shake-effect');
                setTimeout(() => targetEl.classList.remove('shake-effect'), 500);
            }

            await animateMerge(combo, targetIndex);
            let sum = 0;
            combo.indices.forEach(i => { 
                if (board[i]?.isGold) { gold += 100; triggerUiUpdateEffect(goldDisplayEl); showFloatingText("+100G", i, 'score'); } 
                sum += board[i]?.number || 0; 
            });
            
            applyGimmicksAndMutateBoard(combo, sum);
            
            let comboScore = calculateScoreForCombo(combo, sum);
            if(tempBuffs.doubleNextScore) { comboScore *= 2; tempBuffs.doubleNextScore = false; }
            totalScoreFromCombos += comboScore;
            if(currentBoss?.onCombo) currentBoss.onCombo(combo, board);
            
            combo.indices.forEach(i => { if (i !== targetIndex) board[i] = null; });
        }
        if (totalScoreFromCombos > 0) {
            const oldScore = score;
            score += totalScoreFromCombos;
            
            if (targetScore > 0 && oldScore < targetScore && score >= targetScore) {
                if (!targetReached) {
                    targetReached = true;
                    triggerTargetReachedEffect();
                }
            }
            if (targetScore > 0 && score > targetScore) {
                const overtimeScore = score - Math.max(targetScore, oldScore);
                if (overtimeScore > 0) {
                    let goldGained = Math.floor(overtimeScore * (0.1 + stage * 0.005));
                    if(tempBuffs.stageGoldBoost) goldGained = Math.floor(goldGained * tempBuffs.stageGoldBoost);
                    if (goldGained > 0) {
                        gold += goldGained;
                        animateGoldGain(goldGained);
                        triggerUiUpdateEffect(goldDisplayEl);
                    }
                }
            }
            showFloatingText(`+${totalScoreFromCombos.toLocaleString()}`, combos[0].indices[0], 'score');
        }
    }
    
    async function fillEmptyCells() {
        let needsRefill = false;
        for (let i = 0; i < board.length; i++) {
            if (board[i] === null) { board[i] = generateRandomCardData(stage, true); needsRefill = true; }
        }
        if(needsRefill) { updateView(); await new Promise(r => setTimeout(r, 200)); }
    }

    async function applyRankEffects() {
        const effects = [];
        for(let i=0; i<board.length; i++) {
            const card = board[i];
            if(!card || card.type !== 'normal') continue;
            let bonus = 0, neighbors = [], effectColor = '';
            if (card.number >= 75) { neighbors = getNeighborIndices([i], true); bonus = Math.floor(card.number / 20); effectColor = 'var(--blue-glow)'; } 
            else if (card.number >= 25) { neighbors = getNeighborIndices([i], false); bonus = Math.floor(card.number / 10); effectColor = 'var(--green-glow)'; }
            if(bonus > 0) {
                drawRankBonusEffect(i, effectColor);
                neighbors.forEach(nIdx => {
                    if(board[nIdx]?.type === 'normal' && (!relics.unshakable || board[nIdx].animal !== 'üêÆ')) {
                        effects.push({ index: nIdx, bonus: bonus });
                        showFloatingText(`+${bonus}`, nIdx, 'effect');
                    }
                });
            }
        }
        if(effects.length > 0) {
            await new Promise(r => setTimeout(r, 300));
            effects.forEach(eff => { if(board[eff.index]) { board[eff.index].number += eff.bonus; gameBoardEl.children[eff.index]?.classList.add('shake-effect'); } });
            setTimeout(() => document.querySelectorAll('.shake-effect').forEach(el => el.classList.remove('shake-effect')), 500);
        }
    }

    function selectActiveAnimals() { activeAnimals = [...ALL_ANIMALS].sort(() => 0.5 - Math.random()).slice(0, 9); }

    function checkStageEnd(forceWin = false) {
        isProcessing = true;
        let isWin = forceWin || (currentBoss ? currentBoss.remainingGoal <= 0 : (targetScore > 0 && score >= targetScore));
        if (isWin) {
            totalAccumulatedScore += score;
            let goldEarned = Math.floor(score / 10) + (movesLeft * (20 + stage));
            if (tempBuffs.goldMultiplier) goldEarned = Math.floor(goldEarned * tempBuffs.goldMultiplier);
            if (relics.yearOfFortune) goldEarned = Math.floor(goldEarned * 1.25);
            if(tempBuffs.stageGoldBoost) goldEarned = Math.floor(goldEarned * tempBuffs.stageGoldBoost);
            if(tempBuffs.interest) goldEarned += Math.floor(gold * 0.05);
            gold += goldEarned;
            
            if (relics.recyclingBin) {
                tempBuffs.recycledScore = Math.min(1000, Math.floor(board.reduce((acc, c) => acc + (c?.number || 0), 0) * 0.01));
            }

            showStageEndScreen();
        } else {
            showGameOverScreen();
        }
    }

    function showGameOverScreen() {
        const contentEl = document.getElementById('stage-end-content');
        contentEl.innerHTML = `
            <h2 class="stage-clear-text" style="color: var(--red-glow); text-shadow: 0 0 15px var(--red-glow);">GAME OVER</h2>
            <p style="font-size: 1.2em;">Ïä§ÌÖåÏù¥ÏßÄ ${stage} ÌÅ¥Î¶¨Ïñ¥Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.</p>
            <button id="restart-button" class="action-button">Îã§Ïãú ÏãúÏûë</button>
        `;
        stageEndScreen.style.display = 'flex';
        document.getElementById('restart-button').addEventListener('click', initializeGame);
    }
    
    function showStageEndScreen() {
        const contentEl = document.getElementById('stage-end-content');
        if (stage === 20 || stage === 50) {
            const gradeInfo = calculateGrade(totalAccumulatedScore, stage);
            const isFinal = stage === 50;
            contentEl.innerHTML = `
                <h2 class="stage-clear-text">${isFinal ? 'ÏµúÏ¢Ö ÌÅ¥Î¶¨Ïñ¥!' : '20 Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥!'}</h2>
                <p>Ï¥ù ÎàÑÏ†Å Ï†êÏàò: ${totalAccumulatedScore.toLocaleString()}</p>
                <div class="final-grade grade-${gradeInfo.grade}">${gradeInfo.grade}</div>
                <p>${gradeInfo.comment}</p>
                <div style="display: flex; gap: 10px; width: 100%; margin-top: 20px;">
                    ${!isFinal ? '<button id="infinite-mode-button" class="action-button">Î¨¥Ìïú Î™®Îìú Í≥ÑÏÜç</button>' : ''}
                    <button id="restart-button" class="action-button">ÏÉà Í≤åÏûÑ ÏãúÏûë</button>
                </div>
            `;
            if (!isFinal) {
                document.getElementById('infinite-mode-button').addEventListener('click', () => advanceToNextStage());
            }
            document.getElementById('restart-button').addEventListener('click', initializeGame);
        } else {
             contentEl.innerHTML = `
                <h2 class="stage-clear-text">STAGE CLEAR!</h2>
                <p style="font-size: 1.1em; color: var(--secondary-text);">Î≥¥Ïú† Í≥®Îìú: <span id="shop-gold" style="color: var(--gold-color); font-weight: bold;">${gold}</span></p>
                <div class="shop-container"><div id="shop-items" class="shop-items"></div></div>
                <button id="next-stage-button" class="action-button">Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄÎ°ú</button>
            `;
            populateShop();
            document.getElementById('next-stage-button').addEventListener('click', () => advanceToNextStage());
        }
        stageEndScreen.style.display = 'flex';
    }

    function calculateGrade(totalScore, finalStage) {
        let expectedTotal = 0;
        for(let i = 1; i <= finalStage; i++) {
            expectedTotal += Math.floor((1000 + (i - 1) * 600) * Math.pow(1.04, i - 1));
        }
        const ratio = totalScore / expectedTotal;
        if (ratio > 2.0) return { grade: 'S', comment: 'ÎãπÏã†ÏùÄ Ïù¥ Í≤åÏûÑÏùò Ïã†ÏûÖÎãàÎã§!' };
        if (ratio > 1.5) return { grade: 'A', comment: 'ÌõåÎ•≠Ìïú Ï†ÑÎûµÍ∞ÄÏãúÍµ∞Ïöî!' };
        if (ratio > 1.0) return { grade: 'B', comment: 'Ï§ÄÏàòÌïú ÌîåÎ†àÏù¥Ïñ¥ÏûÖÎãàÎã§!' };
        if (ratio > 0.7) return { grade: 'C', comment: 'Ï°∞Í∏àÎßå Îçî ÎÖ∏Î†•Ìï¥Î¥êÏöî!' };
        return { grade: 'D', comment: 'ÏÑ±Ïû•Ïùò Ïó¨ÏßÄÍ∞Ä ÎßéÏäµÎãàÎã§!' };
    }

    function populateShop() {
        const shopItemsContainer = document.getElementById('shop-items');
        shopItemsContainer.innerHTML = '';
        let itemCount = 4;
        if (relics.magnifyingGlass) itemCount++;
        
        const costMultiplier = relics.piggyBank ? 0.9 : 1;
        const presentedItems = Object.keys(allItems).sort(() => 0.5 - Math.random()).slice(0, itemCount);
        
        presentedItems.forEach(key => {
            const item = allItems[key];
            const finalCost = Math.round(item.cost * costMultiplier);
            const itemEl = document.createElement('div');
            itemEl.className = 'item';
            itemEl.innerHTML = `
                <div class="item-info">
                    <h4>${item.name}</h4>
                    <p>${item.desc}</p>
                </div>
                <div style="display: flex; align-items: center;">
                    <span class="item-cost">${finalCost}G</span>
                    <button data-key="${key}" class="action-button" style="width: auto; font-size: 0.9em; padding: 8px 12px;" ${gold < finalCost ? 'disabled' : ''}>Íµ¨Îß§</button>
                </div>`;
            shopItemsContainer.appendChild(itemEl);
        });
        shopItemsContainer.addEventListener('click', handleShopPurchase);
    }

    function handleShopPurchase(e) {
        if(e.target.tagName !== 'BUTTON' || e.target.disabled) return;
        const key = e.target.dataset.key;
        const item = allItems[key];
        const costMultiplier = relics.piggyBank ? 0.9 : 1;
        let finalCost = Math.round(item.cost * costMultiplier);

        if (relics.couponBook && tempBuffs.purchaseCount && tempBuffs.purchaseCount % 3 === 2) {
            finalCost = Math.floor(finalCost / 2);
        }

        if (gold >= finalCost) {
            let cloverChance = relics.fourLeafClover ? 0.02 : 0;
            if (!relics.trickstersLuck || Math.random() > (0.1 + cloverChance)) {
                gold -= finalCost;
            } else {
                showFloatingText("Î¨¥Î£å Íµ¨Îß§!", 12, 'gimmick');
            }

            tempBuffs.purchaseCount = (tempBuffs.purchaseCount || 0) + 1;

            item.effect();
            e.target.disabled = true;
            e.target.textContent = 'ÏôÑÎ£å';
            if (item.instant) {
                if (key !== 'rerollShop') updateView();
            }
            document.getElementById('shop-gold').textContent = gold;
            const allButtons = document.querySelectorAll('#shop-items button');
            allButtons.forEach(btn => {
                if(btn.disabled) return;
                const itemKey = btn.dataset.key;
                const itemCost = Math.round(allItems[itemKey].cost * costMultiplier);
                if (gold < itemCost) btn.disabled = true;
            });
        }
    }

    function showAnimalSelectionModal(callback) {
        animalSelectionCallback = callback;
        const grid = animalSelectionModal.querySelector('#animal-selection-grid');
        grid.innerHTML = activeAnimals.map(animal => 
            `<span class="animal-select-icon" data-animal="${animal}">
                <img src="${getEmojiUrl(animal)}" alt="${animal}" style="pointer-events: none;">
            </span>`
        ).join('');
        animalSelectionModal.classList.add('show');
    }

    function handleAnimalSelection(e) {
        const target = e.target.closest('.animal-select-icon');
        if (!target) return;
        
        const selectedAnimal = target.dataset.animal;
        if (animalSelectionCallback) {
            animalSelectionCallback(selectedAnimal);
        }
        animalSelectionModal.classList.remove('show');
        animalSelectionCallback = null;
    }

    function handleRelicIconClick(e) {
        const target = e.target.closest('span[data-relic-key]');
        if (!target) return;
        const relicKey = target.dataset.relicKey;
        const relic = relics[relicKey];
        if (!relic) return;
        tooltipModal.querySelector('#tooltip-name').textContent = relic.name;
        tooltipModal.querySelector('#tooltip-icon').textContent = relic.icon;
        tooltipModal.querySelector('#tooltip-desc').textContent = `[${RARITY_KR[relic.rarity]}] ${relic.desc}`;
        tooltipModal.classList.add('show');
    }

    function showRelicSelectionScreen() {
        const contentEl = document.getElementById('relic-selection-content');
        const available = Object.entries(allRelics).filter(([key]) => !relics[key]);
        const selection = available.sort(() => 0.5 - Math.random()).slice(0, 3);

        if (selection.length === 0) {
            continueToNextStage();
            return;
        }

        contentEl.innerHTML = `
            <h2 class="relic-title-text">Ïú†Î¨º ÌöçÎìù</h2>
            <p>Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄÎ•º ÏúÑÌïú Ïú†Î¨ºÏùÑ ÌïòÎÇò ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
            <div class="relic-container"><div id="relic-items" class="relic-items"></div></div>
        `;
        
        const relicItemsContainer = contentEl.querySelector('#relic-items');
        selection.forEach(([key, relic]) => {
            const relicEl = document.createElement('div');
            relicEl.className = 'relic-item';
            relicEl.dataset.key = key;
            relicEl.innerHTML = `
                <span class="relic-icon">${relic.icon}</span>
                <div class="relic-info">
                    <h4>${relic.name}</h4>
                    <p>[${RARITY_KR[relic.rarity]}] ${relic.desc}</p>
                </div>
            `;
            relicItemsContainer.appendChild(relicEl);
        });

        relicItemsContainer.addEventListener('click', handleRelicSelection);
        relicSelectionScreen.style.display = 'flex';
    }

    function handleRelicSelection(e) {
        const target = e.target.closest('.relic-item');
        if (!target) return;
        
        const key = target.dataset.key;
        relics[key] = allRelics[key];
        
        relicSelectionScreen.style.display = 'none';
        target.parentElement.removeEventListener('click', handleRelicSelection);
        
        showFloatingText(`Ïú†Î¨º ÌöçÎìù: ${allRelics[key].icon}`, 12, 'gimmick');
        continueToNextStage();
    }
    
    function generateRandomCardData(stage, isNew = false) {
        let cloverChance = relics.fourLeafClover ? 0.02 : 0;
        if (relics.sheepWool && Math.random() < (0.05 + cloverChance)) {
            let maxCard = null, maxNum = -1;
            board.forEach(c => { if(c?.type === 'normal' && c.number > maxNum) { maxNum = c.number; maxCard = c; }});
            if (maxCard) return { ...maxCard, isNew: true };
        }

        if (tempBuffs.guaranteedAnimal && tempBuffs.guaranteedAnimalCount > 0) {
            tempBuffs.guaranteedAnimalCount--;
            return { type: 'normal', animal: tempBuffs.guaranteedAnimal, number: Math.floor(Math.random() * 6) + 1 + Math.min(4, Math.floor(stage / 3)), isNew };
        }

        const stageBonus = Math.min(4, Math.floor(stage / 3));
        let baseNum = Math.floor(Math.random() * 6) + 1 + stageBonus;
        return { type: 'normal', animal: activeAnimals[Math.floor(Math.random() * activeAnimals.length)], number: baseNum, isNew };
    }
    
    function getGimmickText(animal) {
        switch(animal) {
            case 'üêØ': return `Ìò∏ÎûëÏù¥ Í∞ïÌôî!`;
            case 'üê≤': return `Ïö©Ïùò Ìè¨Ìö®!`;
            case 'üê≠': return `Ï•êÏùò Ï∂ïÎ≥µ!`;
            case 'üê¥': return `Îßê ÏßàÏ£º!`;
            case 'üêÆ': return `ÏÜåÏùò Í≤©Î†§!`;
            case 'üê∞': return `ÌÜ†ÎÅºÏùò ÎèÑÏïΩ!`;
            case 'üêç': return `Î±ÄÏùò ÏßÄÌòú!`;
            case 'üêè': return `ÏñëÎñº Ìö®Í≥º!`;
            case 'üêµ': return `ÏõêÏà≠Ïù¥Ïùò Ïû•ÎÇú!`;
            case 'üêî': return `Îã≠Ïùò Ïö∏Ïùå!`;
            case 'üê∂': return `Í∞úÏùò Ï∂©ÏÑ±!`;
            case 'üê∑': return `ÎèºÏßÄÏùò ÌñâÏö¥!`;
            default: return ``;
        }
    }

    function applyGimmicksAndMutateBoard(combo, sum) {
        const multiplier = relics.dragonsOrb ? 1.25 : 1;
        const targetIndex = combo.indices[0];
        let finalNumber = sum;
        
        const gimmickText = getGimmickText(combo.animal);
        if (gimmickText) showFloatingText(gimmickText, targetIndex, 'gimmick');
        
        switch(combo.animal) {
            case 'üê≠': finalNumber += Math.round(combo.indices.length * 15 * multiplier); break;
            case 'üêØ': finalNumber = Math.round(sum * (relics.dragonsOrb ? 1.5 : 1.2)); break;
        }

        board[targetIndex] = { type: 'normal', animal: combo.animal, number: finalNumber, isNew: true };

        switch(combo.animal) {
            case 'üê∞': movesLeft++; initialMoves++; triggerUiUpdateEffect(movesDisplayEl); break;
            case 'üê∂': score += Math.round(combo.indices.length * (50 + stage * 5) * multiplier); break;
            case 'üê∑': gold += Math.round(combo.indices.length * (10 + stage) * multiplier); triggerUiUpdateEffect(goldDisplayEl); break;
            case 'üêÆ': getNeighborIndices([targetIndex], false).forEach(i => { if (board[i]?.type === 'normal') { const b = Math.ceil(board[i].number * 0.1 * multiplier); board[i].number += b; showFloatingText(`+${b}`, i, 'effect'); } }); break;
            case 'üê≤': const p = Math.round(combo.indices.length * (5 + stage) * multiplier); getNeighborIndices([targetIndex], true).forEach(i => { if (board[i]?.type === 'normal') { board[i].number += p; showFloatingText(`+${p}`, i, 'effect'); } }); break;
            case 'üêç': const snakeBonus = Math.ceil(finalNumber * 0.1 * multiplier); board.map((c, i) => ({...c, index: i})).filter(c => c?.type === 'normal' && c.index !== targetIndex).sort((a, b) => a.number - b.number).slice(0, 2).forEach(c => { if(board[c.index]) { board[c.index].number += snakeBonus; showFloatingText(`+${snakeBonus}`, c.index, 'effect'); } }); break;
            case 'üê¥': const col = targetIndex % COLS; for (let r = 0; r < ROWS; r++) { const i = r * COLS + col; if (board[i]?.type === 'normal' && i !== targetIndex) { board[i].number += Math.round(5 * multiplier); } } break;
            case 'üêè': board.forEach((c, i) => { if (c?.type === 'normal' && c.animal === 'üêè' && i !== targetIndex) { c.number += Math.round(10 * multiplier); showFloatingText(`+10`, i, 'effect'); } }); break;
            case 'üêµ': const swappable = board.map((c, i) => i).filter(i => board[i]?.type === 'normal' && i !== targetIndex); if (swappable.length >= 2) { const i1 = swappable.splice(Math.floor(Math.random() * swappable.length), 1)[0]; const i2 = swappable[Math.floor(Math.random() * swappable.length)]; animateDirectSwap(i1, i2).then(() => { [board[i1], board[i2]] = [board[i2], board[i1]]; updateView(); }); } break;
            case 'üêî': const row = Math.floor(targetIndex / COLS); for (let c = 0; c < COLS; c++) { const i = row * COLS + c; if (board[i]?.type === 'normal' && i !== targetIndex) { board[i].number += Math.round(5 * multiplier); } } break;
        }
    }

    function updateView() {
        board.forEach((cardData, i) => {
            const cardEl = gameBoardEl.children[i];
            if (!cardEl) return;
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ ÏßÑÌñâ Ï§ëÏù∏ Î≥¥Ïä§ Ïπ¥ÎìúÏùò ÌÅ¥ÎûòÏä§Îäî Ï¥àÍ∏∞ÌôîÌïòÏßÄ ÏïäÏùå
            const isDestroying = cardEl.classList.contains('cursed-destroy');
            if (!isDestroying) {
                cardEl.className = 'card';
            }

            if(!cardData) { cardEl.innerHTML = ''; return; }
            if (cardData.type === 'cursed') { 
                cardEl.classList.add('cursed'); 
                cardEl.innerHTML = 'ü™®';
            } 
            else if (cardData.type === 'normal') {
                const animalEmoji = cardData.animal || '';
                cardEl.innerHTML = `
                    <div class="card-animal"><img src="${getEmojiUrl(animalEmoji)}" alt="${animalEmoji}"></div>
                    <div class="card-number"></div>`;
                
                const numberEl = cardEl.querySelector('.card-number');
                const numStr = cardData.number > 100000 ? (cardData.number / 1000).toFixed(1) + 'K' : cardData.number.toLocaleString();
                const isSmall = numStr.length > 4;

                numberEl.textContent = numStr;
                numberEl.classList.toggle('small', isSmall);

                if (cardData.isGold) cardEl.classList.add('border-gold');
                else if (cardData.number >= 2500) cardEl.classList.add('border-gold');
                else if (cardData.number >= 1000) cardEl.classList.add('border-red');
                else if (cardData.number >= 500) cardEl.classList.add('border-purple');
                else if (cardData.number >= 200) cardEl.classList.add('border-orange');
                else if (cardData.number >= 75) cardEl.classList.add('border-blue');
                else if (cardData.number >= 25) cardEl.classList.add('border-green');
                if(cardData.isNew) { cardEl.classList.add('spawn-effect'); cardData.isNew = false; }
            }
        });
        document.getElementById('stage').textContent = stage;
        updateScoreboard();
        
        const animalStatusEl = document.getElementById('animal-status-bar').querySelector('.icon-container');
        animalStatusEl.innerHTML = ALL_ANIMALS.map(a => `<span class="${!activeAnimals.includes(a) ? 'banned' : ''}" title="${a}"><img src="${getEmojiUrl(a)}" alt="${a}"></span>`).join('');
        const relicIconsContainer = document.getElementById('relics-display').querySelector('.icon-container');
        relicIconsContainer.innerHTML = Object.entries(relics).map(([k, r]) => `<span data-relic-key="${k}" title="${r.name}">${r.icon}</span>`).join('');
    }

    function updateScoreboard() {
        currentScoreTextEl.classList.remove('score-updated');

        if (currentBoss) {
            targetMarkerEl.style.display = 'none';
            targetTextContainerEl.style.display = 'none';
            document.querySelector('.target-label').style.display = 'none';
            const percentage = (currentBoss.goalValue - currentBoss.remainingGoal) / currentBoss.goalValue * 100;
            scoreProgressFillEl.style.width = `${percentage}%`;
            scoreProgressFillEl.className = 'progress-bar-fill color-red';
            currentScoreTextEl.textContent = `Boss ${currentBoss.remainingGoal}/${currentBoss.goalValue}`;
        } else {
            const targetMarkerPosition = 80;
            targetMarkerEl.style.display = 'block';
            targetTextContainerEl.style.display = 'block';
            document.querySelector('.target-label').style.display = 'block';
            targetMarkerEl.style.left = `${targetMarkerPosition}%`;
            targetTextContainerEl.style.left = `${targetMarkerPosition}%`;
            document.querySelector('.target-label').style.left = `${targetMarkerPosition}%`;

            const progressToTarget = targetScore > 0 ? (score / targetScore) * targetMarkerPosition : 0;
            const displayPercentage = Math.min(progressToTarget, 100);
            
            scoreProgressFillEl.style.width = `${displayPercentage}%`;

            let colorClass = 'color-red';
            if (displayPercentage >= 100) colorClass = 'color-gold';
            else if (displayPercentage >= targetMarkerPosition) colorClass = 'color-blue';
            else if (displayPercentage >= targetMarkerPosition * 0.7) colorClass = 'color-green';
            else if (displayPercentage >= targetMarkerPosition * 0.35) colorClass = 'color-yellow';
            
            scoreProgressFillEl.className = `progress-bar-fill ${colorClass}`;
            currentScoreTextEl.textContent = score.toLocaleString();
            targetScoreTextEl.textContent = targetScore.toLocaleString();
            requestAnimationFrame(() => {
                currentScoreTextEl.classList.add('score-updated');
            });
        }
        movesDisplayEl.textContent = `Move ${movesLeft} / ${initialMoves}`;
        goldDisplayEl.textContent = `üí∞ ${gold}`;
    }

    function triggerUiUpdateEffect(element) {
        if (!element) return;
        element.classList.add('ui-update-effect');
        setTimeout(() => {
            element.classList.remove('ui-update-effect');
        }, 400);
    }
    
    function triggerTargetReachedEffect() {
        targetMarkerEl.classList.add('target-reached-effect');
        targetTextContainerEl.classList.add('target-reached-effect');
        setTimeout(() => {
            targetMarkerEl.classList.remove('target-reached-effect');
            targetTextContainerEl.classList.remove('target-reached-effect');
        }, 600);
    }

    function animateGoldGain(amount) {
        const scoreRect = scoreProgressFillEl.getBoundingClientRect();
        const goldRect = goldDisplayEl.getBoundingClientRect();

        const goldEl = document.createElement('div');
        goldEl.textContent = `+${amount}üí∞`;
        Object.assign(goldEl.style, {
            position: 'fixed',
            left: `${scoreRect.left + scoreRect.width / 2}px`,
            top: `${scoreRect.top}px`,
            color: 'var(--gold-color)',
            fontWeight: 'bold',
            fontSize: '1.2em',
            textShadow: '0 0 5px black',
            zIndex: '300',
            transition: 'transform 0.8s ease-in, opacity 0.8s ease-in'
        });
        document.body.appendChild(goldEl);

        requestAnimationFrame(() => {
            const dx = goldRect.left - scoreRect.left - scoreRect.width / 2;
            const dy = goldRect.top - scoreRect.top;
            goldEl.style.transform = `translate(${dx}px, ${dy}px) scale(0.5)`;
            goldEl.style.opacity = '0';
        });

        setTimeout(() => goldEl.remove(), 800);
    }

    function createShatterEffect(index) {
        const effectsContainer = document.getElementById('html-effects-layer');
        const cardEl = gameBoardEl.children[index];
        if (!effectsContainer || !cardEl) return;

        const rect = cardEl.getBoundingClientRect();
        const containerRect = gameBoardEl.getBoundingClientRect();
        const centerX = rect.left - containerRect.left + rect.width / 2;
        const centerY = rect.top - containerRect.top + rect.height / 2;

        for (let i = 0; i < 15; i++) {
            const particle = document.createElement('div');
            Object.assign(particle.style, {
                position: 'absolute',
                left: `${centerX}px`,
                top: `${centerY}px`,
                width: `${Math.random() * 8 + 4}px`,
                height: particle.style.width,
                background: `rgba(120, 120, 140, ${Math.random() * 0.5 + 0.5})`, // ÏÑùÏÉÅ ÏÉâÍ≥º ÎπÑÏä∑ÌïòÍ≤å
                borderRadius: '2px',
                pointerEvents: 'none',
                transition: 'transform 0.5s ease-out, opacity 0.5s ease-out'
            });
            
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50 + 30;
            const translateX = Math.cos(angle) * distance;
            const translateY = Math.sin(angle) * distance;

            effectsContainer.appendChild(particle);

            requestAnimationFrame(() => {
                particle.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${Math.random() * 360}deg)`;
                particle.style.opacity = '0';
            });

            setTimeout(() => {
                particle.remove();
            }, 500);
        }
    }

    function createCardElement(index) { const c = document.createElement('div'); c.className = 'card'; c.dataset.index = index; return c; }
    
    // [NEW] ÎìúÎûòÍ∑∏ ÏÑ±Îä• ÏµúÏ†ÅÌôîÎ•º ÏúÑÌïú Ìó¨Ìçº Ìï®Ïàò
    function getIndexFromCoords(x, y) {
        if (!boardRect || x < boardRect.left || x > boardRect.right || y < boardRect.top || y > boardRect.bottom) {
            return -1;
        }

        const relX = x - boardRect.left - paddingSize.x;
        const relY = y - boardRect.top - paddingSize.y;

        if (relX < 0 || relY < 0) return -1;

        const col = Math.floor(relX / (cardSize.width + gapSize.x));
        const row = Math.floor(relY / (cardSize.height + gapSize.y));
        
        const xInCell = relX % (cardSize.width + gapSize.x);
        const yInCell = relY % (cardSize.height + gapSize.y);

        if (xInCell > cardSize.width || yInCell > cardSize.height) {
            return -1; // In a gap
        }
        
        if (col >= COLS || row >= ROWS) return -1;

        return row * COLS + col;
    }

    // [MODIFIED] ÎìúÎûòÍ∑∏ ÏãúÏûë Ìï®Ïàò (ÏµúÏ†ÅÌôî Î∞è Í∏∞Ï§ÄÏ†ê Î≥ÄÍ≤Ω Ï†ÅÏö©)
    function handleDragStart(e) {
        if (isProcessing || isDragging) return;
        const card = e.target.closest('.card');
        if (!card || !board[card.dataset.index] || board[card.dataset.index].type !== 'normal') return;
        
        isDragging = true; 
        draggedCardEl = card;
        dragStartRect = card.getBoundingClientRect();
        
        // --- ÎìúÎûòÍ∑∏ ÏÑ±Îä• ÏµúÏ†ÅÌôîÎ•º ÏúÑÌïú Í≥ÑÏÇ∞ (ÏãúÏûë Ïãú Ìïú Î≤àÎßå) ---
        boardRect = gameBoardEl.getBoundingClientRect();
        const firstCardRect = gameBoardEl.children[0]?.getBoundingClientRect();
        const secondCardRect = gameBoardEl.children[1]?.getBoundingClientRect();
        const cardBelowRect = gameBoardEl.children[COLS]?.getBoundingClientRect();
        if(firstCardRect && secondCardRect && cardBelowRect) {
            cardSize.width = firstCardRect.width;
            cardSize.height = firstCardRect.height;
            gapSize.x = secondCardRect.left - firstCardRect.right;
            gapSize.y = cardBelowRect.top - firstCardRect.bottom;
            const computedStyle = getComputedStyle(gameBoardEl);
            paddingSize.x = parseFloat(computedStyle.paddingLeft);
            paddingSize.y = parseFloat(computedStyle.paddingTop);
        }
        // --- Í≥ÑÏÇ∞ ÎÅù ---
        
        dragClone = card.cloneNode(true);
        Object.assign(dragClone.style, { 
            position: 'fixed', 
            width: `${dragStartRect.width}px`, 
            height: `${dragStartRect.height}px`, 
            zIndex: '1000', 
            pointerEvents: 'none', 
            transition: 'none', 
            left: `${dragStartRect.left}px`, 
            top: `${dragStartRect.top}px`,
            boxShadow: '0 8px 25px rgba(0,0,0,0.4)'
        });
        document.body.appendChild(dragClone);
        
        card.classList.add('placeholder');
        
        const touch = e.touches ? e.touches[0] : e;
        currentX = touch.clientX; 
        currentY = touch.clientY;
        
        animationFrameId = requestAnimationFrame(onDragAnimation);
    }

    // [MODIFIED] ÎìúÎûòÍ∑∏ Ïï†ÎãàÎ©îÏù¥ÏÖò Ìï®Ïàò (ÌÑ∞Ïπò Í∏∞Ï§ÄÏ†ê Î≥ÄÍ≤Ω)
    function onDragAnimation() {
        if (!isDragging || !dragClone) return;
        
        // ÌòÑÏû¨ Ïª§ÏÑú ÏúÑÏπòÏóê Ïπ¥ÎìúÏùò Ïö∞Ï∏° ÌïòÎã®Ïù¥ Ïò§ÎèÑÎ°ù transform Í≥ÑÏÇ∞
        const translateX = currentX - dragStartRect.left - dragStartRect.width;
        const translateY = currentY - dragStartRect.top - dragStartRect.height;
        
        dragClone.style.transform = `translate(${translateX}px, ${translateY}px) scale(1.1)`;
        
        animationFrameId = requestAnimationFrame(onDragAnimation);
    }

    // [MODIFIED] ÎìúÎûòÍ∑∏ Ïù¥Îèô Ìï®Ïàò (ÏµúÏ†ÅÌôî Ï†ÅÏö©)
    function handleDragMove(e) {
        if (!isDragging || !dragClone) return;
        if (e.cancelable) e.preventDefault();
        
        const touch = e.touches ? e.touches[0] : e;
        currentX = touch.clientX; 
        currentY = touch.clientY;
        
        if(lastHoveredIndex !== -1 && gameBoardEl.children[lastHoveredIndex]) {
            gameBoardEl.children[lastHoveredIndex].classList.remove('merge-preview', 'swap-preview');
        }

        const newHoveredIndex = getIndexFromCoords(touch.clientX, touch.clientY);
        const targetCard = newHoveredIndex !== -1 ? gameBoardEl.children[newHoveredIndex] : null;
        
        if (targetCard && newHoveredIndex !== -1 && targetCard !== draggedCardEl) {
            const fromData = board[draggedCardEl.dataset.index];
            const toData = board[newHoveredIndex];
            if (fromData && toData?.type === 'normal') {
                targetCard.classList.add(fromData.animal === toData.animal ? 'merge-preview' : 'swap-preview');
            }
        }
        lastHoveredIndex = newHoveredIndex;
    }

    // [MODIFIED] ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å Ìï®Ïàò (ÏµúÏ†ÅÌôî Ï†ÅÏö©)
    function handleDragEnd(e) {
        if (!isDragging) return;

        const fromIndex = parseInt(draggedCardEl.dataset.index);
        const localDragClone = dragClone;
        const localDraggedEl = draggedCardEl;

        isDragging = false;
        draggedCardEl = null;
        dragClone = null;
        cancelAnimationFrame(animationFrameId);
        
        if(lastHoveredIndex !== -1 && gameBoardEl.children[lastHoveredIndex]) {
            gameBoardEl.children[lastHoveredIndex].classList.remove('merge-preview', 'swap-preview');
        }

        const touch = e.changedTouches ? e.changedTouches[0] : e;
        const toIndex = getIndexFromCoords(touch.clientX, touch.clientY);
        const targetCard = toIndex !== -1 ? gameBoardEl.children[toIndex] : null;

        if (targetCard && toIndex !== -1 && targetCard !== localDraggedEl && board[toIndex]) {
            processTurn(fromIndex, toIndex, localDragClone);
        } else {
            localDraggedEl.classList.remove('placeholder');
            const fromRect = localDraggedEl.getBoundingClientRect();
            localDragClone.style.transition = 'left 0.3s ease-out, top 0.3s ease-out, transform 0.3s ease-out';
            localDragClone.style.left = `${fromRect.left}px`;
            localDragClone.style.top = `${fromRect.top}px`;
            localDragClone.style.transform = 'translate(0, 0) scale(1)';
            setTimeout(() => localDragClone?.remove(), 300);
        }
        lastHoveredIndex = -1;
    }
    
    async function animateMerge(combo, targetIndex) {
        const targetEl = gameBoardEl.children[targetIndex], targetRect = targetEl.getBoundingClientRect();
        const promises = combo.indices.map(i => {
            if (i === targetIndex) return Promise.resolve();
            return new Promise(resolve => {
                const movingEl = gameBoardEl.children[i], clone = movingEl.cloneNode(true), movingRect = movingEl.getBoundingClientRect();
                Object.assign(clone.style, { position: 'fixed', left: `${movingRect.left}px`, top: `${movingRect.top}px`, width: `${movingRect.width}px`, height: `${movingRect.height}px`, zIndex: '50', transition: 'transform 0.4s ease-in, opacity 0.4s ease-in', margin: '0' });
                document.body.appendChild(clone);
                movingEl.style.opacity = '0';
                setTimeout(() => { clone.style.transform = `translate(${targetRect.left - movingRect.left}px, ${targetRect.top - movingRect.top}px) scale(0.3)`; clone.style.opacity = '0'; }, 20);
                setTimeout(() => { clone.remove(); movingEl.style.opacity = '1'; resolve(); }, 420);
            });
        });
        await Promise.all(promises);
    }
    
    function animateDirectSwap(fromIndex, toIndex, dragClone) {
        return new Promise(resolve => {
            const fromEl = gameBoardEl.children[fromIndex];
            const toEl = gameBoardEl.children[toIndex];

            if (!fromEl || !toEl || !dragClone) {
                dragClone?.remove();
                fromEl?.classList.remove('placeholder');
                resolve();
                return;
            }

            fromEl.classList.remove('placeholder');
            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            
            const toClone = toEl.cloneNode(true);
            Object.assign(toClone.style, {
                position: 'fixed',
                left: `${toRect.left}px`,
                top: `${toRect.top}px`,
                width: `${toRect.width}px`,
                height: `${toRect.height}px`,
                zIndex: '1001',
                transition: 'transform 0.3s ease-out',
                margin: '0'
            });
            document.body.appendChild(toClone);
            toEl.style.opacity = '0';
            fromEl.style.opacity = '0';

            dragClone.style.transition = 'transform 0.3s ease-out';
            
            const finalTranslateX = toRect.left - dragStartRect.left;
            const finalTranslateY = toRect.top - dragStartRect.top;
            dragClone.style.transform = `translate(${finalTranslateX}px, ${finalTranslateY}px) scale(1)`;

            const deltaX = fromRect.left - toRect.left;
            const deltaY = fromRect.top - toRect.top;
            
            requestAnimationFrame(() => {
                toClone.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            });

            setTimeout(() => {
                dragClone.remove();
                toClone.remove();
                toEl.style.opacity = '1';
                fromEl.style.opacity = '1';
                resolve();
            }, 300);
        });
    }

    function drawRankBonusEffect(index, color) {
        const cardEl = gameBoardEl.children[index];
        const effectsContainer = document.getElementById('html-effects-layer');
        if (!effectsContainer || !cardEl) return;
        
        const rect = cardEl.getBoundingClientRect();
        const containerRect = gameBoardEl.getBoundingClientRect();

        const auraEl = document.createElement('div');
        auraEl.className = 'rank-aura-effect';
        auraEl.style.boxShadow = `0 0 15px 5px ${color}`;
        Object.assign(auraEl.style, {
            left: `${rect.left - containerRect.left + rect.width / 2}px`,
            top: `${rect.top - containerRect.top + rect.height / 2}px`,
            width: `${rect.width * 1.5}px`
        });

        effectsContainer.appendChild(auraEl);
        setTimeout(() => auraEl.remove(), 800);
    }

    function showFloatingText(text, index, type) {
        const effectsContainer = document.getElementById('html-effects-layer');
        const cardEl = gameBoardEl.children[index];
        if (!effectsContainer || !cardEl) return;

        const rect = cardEl.getBoundingClientRect();
        const containerRect = gameBoardEl.getBoundingClientRect();

        const textEl = document.createElement('div');
        textEl.className = `floating-text ${type}`;
        textEl.textContent = text;
        
        Object.assign(textEl.style, {
            left: `${rect.left - containerRect.left + rect.width / 2}px`,
            top: `${rect.top - containerRect.top + rect.height / 2}px`,
        });

        const colorMap = { score: 'var(--gold-color)', gimmick: '#00e5ff', effect: 'var(--purple-glow)' };
        textEl.style.setProperty('--effect-color', colorMap[type] || 'var(--primary-text)');
        effectsContainer.appendChild(textEl);
        setTimeout(() => textEl.remove(), 1500);
    }

    function drawComboLines(combo) {
        const defs = effectsLayer.querySelector('defs');
        effectsLayer.innerHTML = ''; 
        if(defs) effectsLayer.appendChild(defs);

        const boardAreaRect = effectsLayer.getBoundingClientRect();
        if (boardAreaRect.width === 0) return;

        const getCardCenter = (index) => {
            const cardEl = gameBoardEl.children[index];
            if (!cardEl) return null;
            const cardRect = cardEl.getBoundingClientRect();
            return {
                x: cardRect.left - boardAreaRect.left + cardRect.width / 2,
                y: cardRect.top - boardAreaRect.top + cardRect.height / 2,
            };
        };
        
        const sortedIndices = combo.indices.slice().sort((a, b) => a - b);
        const isHorizontal = sortedIndices.every(i => Math.floor(i / COLS) === Math.floor(sortedIndices[0] / COLS));
        const isVertical = sortedIndices.every(i => (i % COLS) === (sortedIndices[0] % COLS));

        if (isHorizontal || isVertical) {
            const startPos = getCardCenter(sortedIndices[0]);
            const endPos = getCardCenter(sortedIndices[sortedIndices.length - 1]);
            if (!startPos || !endPos) return;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${startPos.x} ${startPos.y} L ${endPos.x} ${endPos.y}`;
            path.setAttribute('d', d);
            path.setAttribute('class', 'combo-path');
            effectsLayer.appendChild(path);
            
            const length = path.getTotalLength();
            if (length > 0) {
              path.style.strokeDasharray = length;
              path.style.strokeDashoffset = length;
              requestAnimationFrame(() => path.classList.add('animate'));
            }
        } else {
            const centerPos = getCardCenter(combo.indices[0]);
            if (!centerPos) return;
            const { x: cx, y: cy } = centerPos;

            for (let i = 1; i < combo.indices.length; i++) {
                const startPos = getCardCenter(combo.indices[i]);
                if (!startPos) continue;
                const { x: x2, y: y2 } = startPos;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M ${x2} ${y2} Q ${(cx + x2)/2} ${(cy + y2)/2}, ${cx} ${cy}`;
                path.setAttribute('d', d);
                path.setAttribute('class', 'combo-path');
                effectsLayer.appendChild(path);

                const length = path.getTotalLength();
                if (length > 0) {
                    path.style.strokeDasharray = length;
                    path.style.strokeDashoffset = length;
                    requestAnimationFrame(() => path.classList.add('animate'));
                }
            }
        }

        setTimeout(() => { 
            const defs = effectsLayer.querySelector('defs');
            effectsLayer.innerHTML = '';
            if(defs) effectsLayer.appendChild(defs);
        }, 800);
    }

    function calculateScoreForCombo(combo, numberSum) { 
        let len = combo.indices.length; 
        if (relics.zodiacBlessing) len++; 
        
        let lengthMultiplier = 1.0;
        if(len===4) lengthMultiplier = 1.2; 
        else if(len===5) lengthMultiplier = 1.5;
        else if(len > 5) lengthMultiplier = 1.5 + (len - 5) * 0.2;

        let baseScore = numberSum * lengthMultiplier;
        
        if(relics.kingOfTheMountain && board.filter(c => c?.animal === 'üêØ').length >= 5) baseScore *= 1.1;
        if(relics.oxPerseverance && movesLeft <= 3) baseScore *= 1.15;
        if(relics.flockTogether && combo.animal === 'üêë') baseScore *= (1 + (combo.indices.length * 0.02));
        if(relics.miceCrumbs && len === 3) baseScore *= 1.1;

        return Math.floor(baseScore) * 3; // ÏµúÏ¢Ö Ï†êÏàò 3Î∞∞
    }

    function getNeighborIndices(indices, eightWay = false) { const n=new Set(); const d=eightWay?[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]:[[-1,0],[1,0],[0,-1],[0,1]]; indices.forEach(i=>{const r=Math.floor(i/COLS),c=i%COLS; d.forEach(([dr,dc])=>{const nr=r+dr,nc=c+dc; if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS)n.add(nr*COLS+nc);});}); return Array.from(n).filter(idx => !indices.includes(idx)); }
    
    setupStartScreen();
});
</script>
</body>
</html>
